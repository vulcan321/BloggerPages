
## 8 Command Line Editing8 命令行编辑

This chapter describes the basic features of the <small>GNU</small> command line editing interface. Command line editing is provided by the Readline library, which is used by several different programs, including Bash. Command line editing is enabled by default when using an interactive shell, unless the \--noediting option is supplied at shell invocation. Line editing is also used when using the \-e option to the `read` builtin command (see [Bash Builtin Commands](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins)). By default, the line editing commands are similar to those of Emacs. A vi-style line editing interface is also available. Line editing can be enabled at any time using the \-o emacs or \-o vi options to the `set` builtin command (see [The Set Builtin](https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin)), or disabled using the +o emacs or +o vi options to `set`. 本章介绍<small>GNU</small>除非在 shell 调用时提供 \--noediting当使用 \-e`read` builtin 命令（请参阅 [Bash 内置命令](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins)可以随时使用 \-o emacs\-o vi `set`（请参阅[内置设置](https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin)），或使用 +o emacs+o vi `set`的基本特性 命令行编辑界面。 命令行编辑由 Readline 库提供，该库是 由几个不同的程序使用，包括 Bash。 默认情况下，使用交互式 shell 时会启用命令行编辑， 选项。 选项到 ）。 默认情况下，行编辑命令类似于 Emacs 的命令。 还提供 vi 样式的行编辑界面。 或 builtin 命令中 或 。

-   [Introduction to Line Editing行编辑简介](https://www.gnu.org/software/bash/manual/bash.html#Introduction-and-Notation)
-   [Readline InteractionReadline 交互](https://www.gnu.org/software/bash/manual/bash.html#Readline-Interaction)
-   [Readline Init FileReadline Heat 文件](https://www.gnu.org/software/bash/manual/bash.html#Readline-Init-File)
-   [Bindable Readline Commands可绑定的 readline 命令](https://www.gnu.org/software/bash/manual/bash.html#Bindable-Readline-Commands)
-   [Readline vi ModeReadline vi 模式](https://www.gnu.org/software/bash/manual/bash.html#Readline-vi-Mode)
-   [Programmable Completion可编程完成](https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion)
-   [Programmable Completion Builtins内置可编程补全功能](https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion-Builtins)
-   [A Programmable Completion Example可编程完成示例](https://www.gnu.org/software/bash/manual/bash.html#A-Programmable-Completion-Example)

___

### 8.1 Introduction to Line Editing8.1 行编辑简介

The following paragraphs describe the notation used to represent keystrokes. 以下段落描述了用于表示的符号 击 键。

The text C-k is read as ‘Control-K’ and describes the character produced when the k key is pressed while the Control key is depressed. 文本 C-k在按下 k 读作“Control-K”并描述字符 键的同时按下 Control 键时产生 郁闷。

The text M-k is read as ‘Meta-K’ and describes the character produced when the Meta key (if you have one) is depressed, and the k key is pressed. The Meta key is labeled ALT on many keyboards. On keyboards with two keys labeled ALT (usually to either side of the space bar), the ALT on the left side is generally set to work as a Meta key. The ALT key on the right may also be configured to work as a Meta key or may be configured as some other modifier, such as a Compose key for typing accented characters. 文本 M-k当按下 Meta 键（如果有的话）时产生，并且 kMeta 键在许多键盘上都标记为 ALT在带有两个标记为 ALT空格键），左侧的 ALT右侧的 ALT 读作“Meta-K”并描述字符 键被按下。 。 的键的键盘上（通常位于 通常设置为 用作元键。 键也可以配置为用作 元键，也可以配置为其他修饰符，例如 用于键入重音字符的撰写键。

If you do not have a Meta or ALT key, or another key working as a Meta key, the identical keystroke can be generated by typing ESC _first_, and then typing k. Either process is known as _metafying_ the k key. 如果您没有 Meta 或 ALT一个元键，可以通过_先_键入 ESC，然后键入 k任何一个过程都称为 k 键_元化_ 密钥，或者其他用作 来生成相同的击键。 。

The text M-C-k is read as ‘Meta-Control-k’ and describes the character produced by _metafying_ C-k. 文本 M-C-k由_Metafying_C-k 被读作“Meta-Control-k”，并描述了 产生的特征。

In addition, several keys have their own names. Specifically, DEL, ESC, LFD, SPC, RET, and TAB all stand for themselves when seen in this text, or in an init file (see [Readline Init File](https://www.gnu.org/software/bash/manual/bash.html#Readline-Init-File)). If your keyboard lacks a LFD key, typing C-j will produce the desired character. The RET key may be labeled Return or Enter on some keyboards. DEL、ESC、LFD、SPC、RET 和 TAB（请参阅 [Readline 初始化文件](https://www.gnu.org/software/bash/manual/bash.html#Readline-Init-File)如果您的键盘缺少 LFD 键，键入 C-jRET 键可能标记为 Return 或 Enter此外，几个键都有自己的名称。 具体说来 全部 在此文本或初始化文件中看到时，代表自己 ）。 即可 产生所需的字符。 on 一些键盘。

___

### 8.2 Readline Interaction8.2 Readline 交互

Often during an interactive session you type in a long line of text, only to notice that the first word on the line is misspelled. The Readline library gives you a set of commands for manipulating the text as you type it in, allowing you to just fix your typo, and not forcing you to retype the majority of the line. Using these editing commands, you move the cursor to the place that needs correction, and delete or insert the text of the corrections. Then, when you are satisfied with the line, you simply press RET. You do not have to be at the end of the line to press RET; the entire line is accepted regardless of the location of the cursor within the line. 该行，您只需按 RET行尾按 RET通常在交互式会话中，您输入一长行文本， 只是注意到行上的第一个单词拼写错误。 这 Readline 库为您提供了一组用于操作文本的命令 当你输入它时，允许你只修复你的错别字，而不是强迫 您重新键入该行的大部分内容。 使用这些编辑命令， 将光标移动到需要更正的位置，然后删除或 插入更正案文。 然后，当您满意时 即可。 您不必在 ;整条线路被接受 无论光标在行中的位置如何。

-   [Readline Bare Essentials](https://www.gnu.org/software/bash/manual/bash.html#Readline-Bare-Essentials)
-   [Readline Movement Commands](https://www.gnu.org/software/bash/manual/bash.html#Readline-Movement-Commands)
-   [Readline Killing CommandsReadline 杀戮命令](https://www.gnu.org/software/bash/manual/bash.html#Readline-Killing-Commands)
-   [Readline ArgumentsReadline 参数](https://www.gnu.org/software/bash/manual/bash.html#Readline-Arguments)
-   [Searching for Commands in the History在历史记录中搜索命令](https://www.gnu.org/software/bash/manual/bash.html#Searching)

___

#### 8.2.1 Readline Bare Essentials8.2.1 Readline 基本要素

In order to enter characters into the line, simply type them. The typed character appears where the cursor was, and then the cursor moves one space to the right. If you mistype a character, you can use your erase character to back up and delete the mistyped character. 要在行中输入字符，只需键入它们即可。 键入的 字符出现在光标所在的位置，然后光标移动一个 右边的空间。 如果你输入了一个错误的字符，你可以使用 擦除字符以备份并删除键入错误的字符。

Sometimes you may mistype a character, and not notice the error until you have typed several other characters. In that case, you can type C-b to move the cursor to the left, and then correct your mistake. Afterwards, you can move the cursor to the right with C-f. 在这种情况下，您可以键入 C-b与 C-f有时您可能会打错字符，并且 在键入其他几个字符之前，不会注意到该错误。 在 将光标向左移动，然后 纠正你的错误。 之后，您可以将光标向右移动 .

When you add text in the middle of a line, you will notice that characters to the right of the cursor are ‘pushed over’ to make room for the text that you have inserted. Likewise, when you delete text behind the cursor, characters to the right of the cursor are ‘pulled back’ to fill in the blank space created by the removal of the text. A list of the bare essentials for editing the text of an input line follows. 当您在行中间添加文本时，您会注意到字符 光标右侧被“推过”，为文本腾出空间 您插入的。 同样，当您删除光标后面的文本时， 光标右侧的字符被“拉回”以填充 删除文本时产生的空白区域。 裸露的清单 以下是编辑输入行文本的基本知识。

C-bC-b型

Move back one character. 向后移动一个字符。

C-fC-f（英语：C-f）

Move forward one character. 向前移动一个字符。

DEL or BackspaceDEL 或退格键

Delete the character to the left of the cursor. 删除光标左侧的字符。

C-dC-d型

Delete the character underneath the cursor. 删除光标下方的字符。

Printing characters打印字符

Insert the character into the line at the cursor. 将字符插入光标处的行中。

C-\_ or C-x C-uC-\_ 或 C-x C-u

Undo the last editing command. You can undo all the way back to an empty line. 撤消上一个编辑命令。 您可以一直撤消回 空行。

(Depending on your configuration, the Backspace key might be set to delete the character to the left of the cursor and the DEL key set to delete the character underneath the cursor, like C-d, rather than the character to the left of the cursor.) （根据您的配置，Backspace删除光标左侧的字符和 DEL删除光标下方的字符，如 C-d 键可能设置为 键集 ，而不是 比光标左侧的字符。

___

#### 8.2.2 Readline Movement Commands8.2.2 Readline 移动命令

The above table describes the most basic keystrokes that you need in order to do editing of the input line. For your convenience, many other commands have been added in addition to C-b, C-f, C-d, and DEL. Here are some commands for moving more rapidly about the line. 除了 C-b、C-fC-d 和 DEL上表描述了您需要的最基本的击键 以便对输入行进行编辑。 为了您的方便，许多 、 。 以下是一些用于更快移动的命令 关于这条线。

C-aC-a（英语：C-a）

Move to the start of the line. 移动到行的开头。

C-eC-e

Move to the end of the line. 移动到行的末尾。

M-f男-女

Move forward a word, where a word is composed of letters and digits. 向前移动一个单词，其中单词由字母和数字组成。

M-bM-b

Move backward a word. 向后移动一个词。

C-lC-L型

Clear the screen, reprinting the current line at the top. 清除屏幕，重新打印顶部的当前行。

Notice how C-f moves forward a character, while M-f moves forward a word. It is a loose convention that control keystrokes operate on characters while meta keystrokes operate on words. 请注意 C-f 如何向前移动字符，而 M-f 如何移动 转发一个词。 这是一个控制击键的松散约定 对字符进行操作，而元击键对单词进行操作。

___

#### 8.2.3 Readline Killing Commands8.2.3 Readline 杀戮命令

_Killing_ text means to delete the text from the line, but to save it away for later use, usually by _yanking_ (re-inserting) it back into the line. (‘Cut’ and ‘paste’ are more recent jargon for ‘kill’ and ‘yank’.)

If the description for a command says that it ‘kills’ text, then you can be sure that you can get the text back in a different (or the same) place later. 如果命令的描述说它“杀死”了文本，那么你可以 确保您可以以不同（或相同）的方式取回文本 稍后放置。

When you use a kill command, the text is saved in a _kill-ring_. Any number of consecutive kills save all of the killed text together, so that when you yank it back, you get it all. The kill ring is not line specific; the text that you killed on a previously typed line is available to be yanked back later, when you are typing another line. 使用 kill 命令时，文本将保存在 _kill-ring_ 中。 任意数量的连续击杀都会将所有被击杀的文本保存在一起，因此 当你把它拉回来时，你就会得到一切。 杀戮 环不是特定于线路的;您之前在 键入的行可以在以后键入时拉回 另一行。

Here is the list of commands for killing text. 以下是用于杀死文本的命令列表。

C-kC-k

Kill the text from the current cursor position to the end of the line. 从当前光标位置到行尾终止文本。

M-d医学博士

Kill from the cursor to the end of the current word, or, if between words, to the end of the next word. Word boundaries are the same as those used by M-f. 单词边界与 M-f从光标到当前单词的末尾，或者，如果介于 单词，到下一个单词的末尾。 使用的边界相同。

M-DEL

Kill from the cursor to the start of the current word, or, if between words, to the start of the previous word. Word boundaries are the same as those used by M-b. 单词边界与 M-b从光标到当前单词的开头终止，或者，如果介于 单词，到前一个单词的开头。 使用的边界相同。

C-wC-w

Kill from the cursor to the previous whitespace. This is different than M-DEL because the word boundaries differ. M-DEL从光标到上一个空格处的 kill。 这与 ，因为单词边界不同。

Here is how to _yank_ the text back into the line. Yanking means to copy the most-recently-killed text from the kill buffer. 以下是将文本_拉_回行中的方法。 拉 表示从终止缓冲区复制最近终止的文本。

C-yC-y

Yank the most recently killed text back into the buffer at the cursor. 将最近终止的文本拉回光标处的缓冲区中。

M-yM-y

Rotate the kill-ring, and yank the new top. You can only do this if the prior command is C-y or M-y. 先验命令是 C-y 或 M-y旋转杀戮环，然后拉动新的顶部。 只有在以下情况下才能执行此操作 。

___

#### 8.2.4 Readline Arguments8.2.4 Readline 参数

You can pass numeric arguments to Readline commands. Sometimes the argument acts as a repeat count, other times it is the _sign_ of the argument that is significant. If you pass a negative argument to a command which normally acts in a forward direction, that command will act in a backward direction. For example, to kill text back to the start of the line, you might type ‘M-- C-k’. 参数充当重复计数，其他时候它是在行的开头，您可以键入“M-- C-k可以将数值参数传递给 Readline 命令。 有时 重要的参数。 如果将否定参数传递给 通常向前作用的命令，该命令将 向后行动。 例如，要将文本杀死回 ”。

The general way to pass numeric arguments to a command is to type meta digits before the command. If the first ‘digit’ typed is a minus sign (‘\-’), then the sign of the argument will be negative. Once you have typed one meta digit to get the argument started, you can type the remainder of the digits, and then the command. For example, to give the C-d command an argument of 10, you could type ‘M-1 0 C-d’, which will delete the next ten characters on the input line. 符号 （'\-C-d 命令参数为 10，您可以键入“M-1 0 C-d将数值参数传递给命令的一般方法是键入 meta 命令前的数字。 如果键入的第一个“数字”是减号 '），则参数的符号将为负数。 一次 您已经输入了一个元数字来启动参数，您可以键入 其余的数字，然后是命令。 例如，给 ”， 这将删除输入行上接下来的十个字符。

___

#### 8.2.5 Searching for Commands in the History8.2.5 在历史记录中搜索命令

Readline provides commands for searching through the command history (see [Bash History Facilities](https://www.gnu.org/software/bash/manual/bash.html#Bash-History-Facilities)) for lines containing a specified string. There are two search modes: _incremental_ and _non-incremental_. （请参阅 [Bash 历史记录工具](https://www.gnu.org/software/bash/manual/bash.html#Bash-History-Facilities)有两种搜索模式：_增量_搜索和非_增量_Readline 提供用于搜索命令历史记录的命令 ） 对于包含指定字符串的行。 搜索模式。

Incremental searches begin before the user has finished typing the search string. As each character of the search string is typed, Readline displays the next entry from the history matching the string typed so far. An incremental search requires only as many characters as needed to find the desired history entry. To search backward in the history for a particular string, type C-r. Typing C-s searches forward through the history. The characters present in the value of the `isearch-terminators` variable are used to terminate an incremental search. If that variable has not been assigned a value, the ESC and C-J characters will terminate an incremental search. C-g will abort an incremental search and restore the original line. When the search is terminated, the history entry containing the search string becomes the current line. C-r。 键入 C-s`isearch-terminators`如果尚未为该变量赋值，则 ESCC-JC-g增量搜索在用户键入完 搜索字符串。 键入搜索字符串的每个字符时，将显示 Readline 历史记录中的下一个条目与到目前为止键入的字符串匹配。 增量搜索只需要所需数量的字符 找到所需的历史记录条目。 若要在历史记录中向后搜索特定字符串，请键入 可向前搜索历史记录。 变量的值中存在的字符 用于终止增量搜索。 和 字符将终止增量搜索。 将中止增量搜索并恢复原始行。 当搜索终止时，包含 搜索字符串将成为当前行。

To find other matching entries in the history list, type C-r or C-s as appropriate. This will search backward or forward in the history for the next entry matching the search string typed so far. Any other key sequence bound to a Readline command will terminate the search and execute that command. For instance, a RET will terminate the search and accept the line, thereby executing the command from the history list. A movement command will terminate the search, make the last line found the current line, and begin editing. 若要在历史记录列表中查找其他匹配条目，请键入 C-rC-s例如，RET 或 （视情况而定）。 这将在历史记录中向后或向前搜索下一个 与到目前为止键入的搜索字符串匹配的条目。 绑定到 Readline 命令的任何其他键序列都将终止 搜索并执行该命令。 将终止搜索并接受 行，从而执行历史记录列表中的命令。 移动命令将终止搜索，使找到最后一行 当前行，然后开始编辑。

Readline remembers the last incremental search string. If two C-rs are typed without any intervening characters defining a new search string, any remembered search string is used. C-rReadline 会记住最后一个增量搜索字符串。 如果两个 时没有任何中间字符定义新的 搜索字符串，使用任何记住的搜索字符串。

Non-incremental searches read the entire search string before starting to search for matching history lines. The search string may be typed by the user or be part of the contents of the current line. 非增量搜索在开始之前读取整个搜索字符串 以搜索匹配的历史记录行。 搜索字符串可能是 由用户键入或成为当前行内容的一部分。

___

### 8.3 Readline Init File8.3 Readline Heat 文件

Although the Readline library comes with a set of Emacs-like keybindings installed by default, it is possible to use a different set of keybindings. Any user can customize programs that use Readline by putting commands in an _inputrc_ file, conventionally in their home directory. The name of this file is taken from the value of the shell variable `INPUTRC`. If that variable is unset, the default is ~/.inputrc. If that file does not exist or cannot be read, the ultimate default is /etc/inputrc. The `bind` builtin command can also be used to set Readline keybindings and variables. See [Bash Builtin Commands](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins). _inputrc_file 取自 shell 变量 `INPUTRC`该变量未设置，默认值为 ~/.inputrc/etc/inputrc`bind`请参阅 [Bash 内置命令](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins)虽然 Readline 库附带了一组类似 Emacs 的 默认情况下安装的键绑定，可以使用不同的集合 的键绑定。 任何用户都可以通过将 文件中的命令， 通常在其主目录中。 这个的名字 的值。 如果 。 如果那样的话 文件不存在或无法读取，最终默认为 中。 builtin 命令也可用于设置 Readline 键绑定和变量。 。

When a program which uses the Readline library starts up, the init file is read, and the key bindings are set. 当使用 Readline 库的程序启动时， 读取 init 文件，并设置密钥绑定。

In addition, the `C-x C-r` command re-reads this init file, thus incorporating any changes that you might have made to it. 此外，`C-x C-r` 命令会重新读取此 init 文件，因此 合并您可能对其所做的任何更改。

-   [Readline Init File SyntaxReadline 初始化文件语法](https://www.gnu.org/software/bash/manual/bash.html#Readline-Init-File-Syntax)
-   [Conditional Init Constructs条件初始化构造](https://www.gnu.org/software/bash/manual/bash.html#Conditional-Init-Constructs)
-   [Sample Init File示例热文件](https://www.gnu.org/software/bash/manual/bash.html#Sample-Init-File)

___

#### 8.3.1 Readline Init File Syntax8.3.1 Readline 初始化文件语法

There are only a few basic constructs allowed in the Readline init file. Blank lines are ignored. Lines beginning with a ‘#’ are comments. Lines beginning with a ‘$’ indicate conditional constructs (see [Conditional Init Constructs](https://www.gnu.org/software/bash/manual/bash.html#Conditional-Init-Constructs)). Other lines denote variable settings and key bindings. 以“#以“$构造（请参阅[条件初始化构造](https://www.gnu.org/software/bash/manual/bash.html#Conditional-Init-Constructs)中只允许使用几个基本结构 Readline 初始化文件。 空行将被忽略。 ”开头的行是注释。 ”开头的行表示有条件的 ）。 其他线路 表示变量设置和键绑定。

Variable Settings变量设置

You can modify the run-time behavior of Readline by altering the values of variables in Readline using the `set` command within the init file. The syntax is simple: 在 init 文件中使用 `set`您可以通过以下方式修改 Readline 的运行时行为 更改 Readline 中变量的值 命令。 语法很简单：

Here, for example, is how to change from the default Emacs-like key binding to use `vi` line editing commands: `vi`例如，这里是如何 从默认的类似 Emacs 的键绑定更改为使用 行编辑命令：

Variable names and values, where appropriate, are recognized without regard to case. Unrecognized variable names are ignored. 在适当的情况下，可以识别变量名称和值，而不考虑变量名称和值 到案例。 无法识别的变量名称将被忽略。

Boolean variables (those that can be set to on or off) are set to on if the value is null or empty, on (case-insensitive), or 1. Any other value results in the variable being set to off. 该值为 null 或空、on布尔变量（可以设置为 on 或 off 的变量）设置为 on，如果 （不区分大小写）或 1。 任何其他 value 会导致变量设置为 off。

The `bind -V` command lists the current Readline variable names and values. See [Bash Builtin Commands](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins). bind \-V和价值观。 请参阅 [Bash 内置命令](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins) 命令列出当前的 Readline 变量名称 。

A great deal of run-time behavior is changeable with the following variables. 大量的运行时行为可以通过以下方式更改 变量。

`active-region-start-color`

A string variable that controls the text color and background when displaying the text in the active region (see the description of `enable-active-region` below). This string must not take up any physical character positions on the display, so it should consist only of terminal escape sequences. It is output to the terminal before displaying the text in the active region. This variable is reset to the default value whenever the terminal type changes. The default value is the string that puts the terminal in standout mode, as obtained from the terminal’s terminfo description. A sample value might be ‘\\e\[01;33m’. `enable-active-region`示例值可能为 '\\e\[01;33m一个字符串变量，用于控制显示时的文本颜色和背景 活动区域中的文本（请参阅 ）。 此字符串不得占用显示屏上的任何物理字符位置， 所以它应该只由终端转义序列组成。 在活动区域中显示文本之前，它将输出到终端。 每当终端类型更改时，此变量都会重置为默认值。 默认值是将终端置于突出模式的字符串， 从终端的 terminfo 描述中获得。 '。

`active-region-end-color`

A string variable that "undoes" the effects of `active-region-start-color` and restores "normal" terminal display appearance after displaying text in the active region. This string must not take up any physical character positions on the display, so it should consist only of terminal escape sequences. It is output to the terminal after displaying the text in the active region. This variable is reset to the default value whenever the terminal type changes. The default value is the string that restores the terminal from standout mode, as obtained from the terminal’s terminfo description. A sample value might be ‘\\e\[0m’. 一个字符串变量，用于“撤消”`active-region-start-color`示例值可能为“\\e\[0m 的影响 并在显示文本后恢复“正常”终端显示外观 在活动区域中。 此字符串不得占用显示屏上的任何物理字符位置， 所以它应该只由终端转义序列组成。 在活动区域中显示文本后，它将输出到终端。 每当终端类型更改时，此变量都会重置为默认值。 默认值是将终端从突出模式还原的字符串， 从终端的 terminfo 描述中获得。 ”。

`bell-style`

Controls what happens when Readline wants to ring the terminal bell. If set to ‘none’, Readline never rings the bell. If set to ‘visible’, Readline uses a visible bell if one is available. If set to ‘audible’ (the default), Readline attempts to ring the terminal’s bell. 如果设置为“none“visible如果设置为“audible控制当 Readline 想要敲响终端铃时发生的情况。 ”，则 Readline 永远不会响起铃声。 如果设置为 ”，Readline 使用可见铃铛（如果有）。 见”（默认值），Readline 会尝试响铃 航站楼的铃声。

`bind-tty-special-chars`

If set to ‘on’ (the default), Readline attempts to bind the control characters treated specially by the kernel’s terminal driver to their Readline equivalents. 如果设置为“on”（默认值），Readline 将尝试绑定控件 由内核终端驱动程序专门处理的字符 Readline 等效项。

`blink-matching-paren`

If set to ‘on’, Readline attempts to briefly move the cursor to an opening parenthesis when a closing parenthesis is inserted. The default is ‘off’.

`colored-completion-prefix`

If set to ‘on’, when listing completions, Readline displays the common prefix of the set of possible completions using a different color. The color definitions are taken from the value of the `LS_COLORS` environment variable. If there is a color definition in `LS_COLORS` for the custom suffix ‘readline-colored-completion-prefix’, Readline uses this color for the common prefix instead of its default. The default is ‘off’. 如果设置为“on颜色定义取自 `LS_COLORS`如果自定义后缀的 `LS_COLORS`'readline-colored-completion-prefix默认值为“off”，则在列出完成时，Readline 将显示 使用不同颜色的可能补全集的通用前缀。 的值 环境变量。 中有颜色定义 '，Readline 使用此颜色 通用前缀，而不是其默认前缀。 ”。

`colored-stats`

If set to ‘on’, Readline displays possible completions using different colors to indicate their file type. The color definitions are taken from the value of the `LS_COLORS` environment variable. The default is ‘off’. 如果设置为“on颜色定义取自 `LS_COLORS`默认值为“off”，则 Readline 会使用不同的方式显示可能的完成 颜色来指示其文件类型。 的值 环境变量。 ”。

The string to insert at the beginning of the line when the `insert-comment` command is executed. The default value is `"#"`. `insert-comment`为`"#"`当 命令。 默认值 。

`completion-display-width`

The number of screen columns used to display possible matches when performing completion. The value is ignored if it is less than 0 or greater than the terminal screen width. A value of 0 will cause matches to be displayed one per line. The default value is -1. 用于显示可能匹配项的屏幕列数 执行完成时。 如果该值小于 0 或大于终端，则忽略该值 屏幕宽度。 值为 0 将导致每行显示一个匹配项。 默认值为 -1。

`completion-ignore-case`

If set to ‘on’, Readline performs filename matching and completion in a case-insensitive fashion. The default value is ‘off’. 如果设置为“on默认值为“off”，Readline 将执行文件名匹配和完成 以不区分大小写的方式。 ”。

`completion-map-case`

If set to ‘on’, and completion-ignore-case is enabled, Readline treats hyphens (‘\-’) and underscores (‘\_’) as equivalent when performing case-insensitive filename matching and completion. The default value is ‘off’. 如果设置为“on”，并且启用了 completion-ignore-case当默认值为“off，则 Readline 执行不区分大小写的文件名匹配和补全。 ”。

`completion-prefix-display-length`

The length in characters of the common prefix of a list of possible completions that is displayed without modification. When set to a value greater than zero, common prefixes longer than this value are replaced with an ellipsis when displaying possible completions. 可能列表的通用前缀的字符长度 不加修改而显示的完成。 当设置为 值大于零，常用前缀长于此值 在显示可能的完成时替换为省略号。

`completion-query-items`

The number of possible completions that determines when the user is asked whether the list of possibilities should be displayed. If the number of possible completions is greater than or equal to this value, Readline will ask whether or not the user wishes to view them; otherwise, they are simply listed. This variable must be set to an integer value greater than or equal to zero. A zero value means Readline should never ask; negative values are treated as zero. The default limit is `100`. 默认限制为 `100`确定用户何时完成的可能完成次数 询问是否应显示可能性列表。 如果可能的完成次数大于或等于此值， Readline 将询问用户是否希望查看它们; 否则，它们只是被列出。 此变量必须设置为大于或等于零的整数值。 零值表示 Readline 永远不应该询问;负值为 视为零。 。

`convert-meta`

If set to ‘on’, Readline will convert characters with the eighth bit set to an <small>ASCII</small> key sequence by stripping the eighth bit and prefixing an ESC character, converting them to a meta-prefixed key sequence. The default value is ‘on’, but will be set to ‘off’ if the locale is one that contains eight-bit characters. This variable is dependent on the `LC_CTYPE` locale category, and may change if the locale is changed. 如果设置为“on通过剥离第八位将第八位设置为 <small>ASCII</small>bit 并在 ESC默认值为“on如果区域设置包含此变量取决于`LC_CTYPE`”，Readline 将使用 键序列 字符前加上前缀，将它们转换为 元前缀键序列。 ”，但 八位字符。 区域设置类别，并且 如果区域设置更改，则可能会更改。

`disable-completion`

If set to ‘On’, Readline will inhibit word completion. Completion characters will be inserted into the line as if they had been mapped to `self-insert`. The default is ‘off’. 如果设置为“On已映射到`self-insert`。 默认值为“off”，Readline 将禁止单词完成。 完成字符将插入到行中，就好像它们有 ”。

`echo-control-characters`

When set to ‘on’, on operating systems that indicate they support it, Readline echoes a character corresponding to a signal generated from the keyboard. The default is ‘on’. 当设置为“on键盘。 默认值为“on”时，在指示其支持它的操作系统上， Readline 回显一个字符，该字符对应于从 ”。

`editing-mode`

The `editing-mode` variable controls which default set of key bindings is used. By default, Readline starts up in Emacs editing mode, where the keystrokes are most similar to Emacs. This variable can be set to either ‘emacs’ or ‘vi’. `editing-mode`设置为“emacs”或“vi 变量控制默认集 使用键绑定。 默认情况下，Readline 在 Emacs 编辑中启动 模式，其中击键与 Emacs 最相似。 此变量可以是 ”。

`emacs-mode-string`

If the show-mode-in-prompt variable is enabled, this string is displayed immediately before the last line of the primary prompt when emacs editing mode is active. The value is expanded like a key binding, so the standard set of meta- and control prefixes and backslash escape sequences is available. Use the ‘\\1’ and ‘\\2’ escapes to begin and end sequences of non-printing characters, which can be used to embed a terminal control sequence into the mode string. The default is ‘@’. 如果启用了 show-mode-in-prompt使用“\\1”和“\\2默认值为“@ 变量， 此字符串紧接在主节点的最后一行之前显示 当 EMACS 编辑模式处于活动状态时提示。 该值像 键绑定，因此 meta- 和 control 前缀的标准集和 反斜杠转义序列可用。 ”转义来开始和结束序列 非打印字符，可用于嵌入终端控件 序列到模式字符串中。 ”。

`enable-active-region`

The _point_ is the current cursor position, and _mark_ refers to a saved cursor position (see [Commands For Moving](https://www.gnu.org/software/bash/manual/bash.html#Commands-For-Moving)). The text between the point and mark is referred to as the _region_. When this variable is set to ‘On’, Readline allows certain commands to designate the region as _active_. When the region is active, Readline highlights the text in the region using the value of the `active-region-start-color`, which defaults to the string that enables the terminal’s standout mode. The active region shows the text inserted by bracketed-paste and any matching text found by incremental and non-incremental history searches. The default is ‘On’. _该点_是当前光标位置，_标记_到保存的光标位置（请参阅[移动命令](https://www.gnu.org/software/bash/manual/bash.html#Commands-For-Moving)点和标记之间的文本称为_区域_当此变量设置为“On将区域指定为_活动_`active-region-start-color`默认值为“On是指 ）。 。 ”时，Readline 允许某些命令 区域。 当区域处于活动状态时，Readline 会使用 的值，默认为 启用的字符串 终端的突出模式。 活动区域显示通过括号粘贴插入的文本，以及任何 通过增量和非增量历史记录搜索找到的匹配文本。 ”。

`enable-bracketed-paste`

When set to ‘On’, Readline configures the terminal to insert each paste into the editing buffer as a single string of characters, instead of treating each character as if it had been read from the keyboard. This is called putting the terminal into _bracketed paste mode_; it prevents Readline from executing any editing commands bound to key sequences appearing in the pasted text. The default is ‘On’. 当设置为“On这称为将终端置于_括号粘贴模式_默认值为“On”时，Readline 会将终端配置为插入每个 改为以单个字符串的形式粘贴到编辑缓冲区中 将每个字符视为从键盘上读取的字符。 ; 它阻止 Readline 执行绑定到键的任何编辑命令 粘贴文本中出现的序列。 ”。

`enable-keypad`

When set to ‘on’, Readline will try to enable the application keypad when it is called. Some systems need this to enable the arrow keys. The default is ‘off’. 设置为“on箭头键。 默认值为“off”时，Readline 将尝试启用应用程序 调用时的键盘。 某些系统需要此功能才能启用 ”。

`enable-meta-key`

When set to ‘on’, Readline will try to enable any meta modifier key the terminal claims to support when it is called. On many terminals, the meta key is used to send eight-bit characters. The default is ‘on’. 当设置为“on默认值为“on”时，Readline 将尝试启用任何元修饰符 密钥：终端在调用时声称支持。 在许多终端上， meta 键用于发送 8 位字符。 ”。

`expand-tilde`

If set to ‘on’, tilde expansion is performed when Readline attempts word completion. The default is ‘off’. 如果设置为“on尝试单词补全。 默认值为“off”，则在 Readline 时执行波浪号扩展 ”。

`history-preserve-point`

If set to ‘on’, the history code attempts to place the point (the current cursor position) at the same location on each history line retrieved with `previous-history` or `next-history`. The default is ‘off’. 如果设置为“on使用`previous-history`或`next-history`。 默认值为“off”，则历史代码会尝试放置点 （ 当前光标位置）处 检索到的每个历史记录行上的相同位置 ”。

`history-size`

Set the maximum number of history entries saved in the history list. If set to zero, any existing history entries are deleted and no new entries are saved. If set to a value less than zero, the number of history entries is not limited. By default, the number of history entries is not limited. If an attempt is made to set history-size to a non-numeric value, the maximum number of history entries will be set to 500. 如果尝试将 history-size设置历史记录列表中保存的最大历史记录条目数。 如果设置为零，则删除任何现有历史记录条目，并且不会删除新条目 得救了。 如果设置为小于零的值，则历史记录条目数不 有限。 默认情况下，历史记录条目的数量不受限制。 设置为非数值， 历史条目的最大数量将设置为 500。

`horizontal-scroll-mode`

This variable can be set to either ‘on’ or ‘off’. Setting it to ‘on’ means that the text of the lines being edited will scroll horizontally on a single screen line when they are longer than the width of the screen, instead of wrapping onto a new screen line. This variable is automatically set to ‘on’ for terminals of height 1. By default, this variable is set to ‘off’. 此变量可以设置为“on”或“off“on对于高度为 1 的端子，此变量自动设置为“on默认情况下，此变量设置为“off”。 设置它 ”表示正在编辑的行的文本将滚动 当它们长于宽度时，水平在单条屏幕线上 的屏幕，而不是换行到新的屏幕线上。 ”。 ”。

`input-meta`

If set to ‘on’, Readline will enable eight-bit input (it will not clear the eighth bit in the characters it reads), regardless of what the terminal claims it can support. The default value is ‘off’, but Readline will set it to ‘on’ if the locale contains eight-bit characters. The name `meta-flag` is a synonym for this variable. This variable is dependent on the `LC_CTYPE` locale category, and may change if the locale is changed. 如果设置为“on默认值为 'off'，但 Readline 会将其设置为 'on名称 `meta-flag`此变量取决于`LC_CTYPE`”，Readline 将启用 8 位输入（它 不会清除它读取的字符中的第八位）， 无论终端声称它可以支持什么。 这 '，如果 区域设置包含八位字符。 是此变量的同义词。 区域设置类别，并且 如果区域设置更改，则可能会更改。

`isearch-terminators`

The string of characters that should terminate an incremental search without subsequently executing the character as a command (see [Searching for Commands in the History](https://www.gnu.org/software/bash/manual/bash.html#Searching)). If this variable has not been given a value, the characters ESC and C-J will terminate an incremental search. 随后将字符作为命令执行（请参阅[在历史记录中搜索命令](https://www.gnu.org/software/bash/manual/bash.html#Searching)如果尚未为此变量赋值，则字符 ESCC-J应终止增量搜索的字符串，而不使用 ）。 和 将终止增量搜索。

`keymap`

Sets Readline’s idea of the current keymap for key binding commands. Built-in `keymap` names are `emacs`, `emacs-standard`, `emacs-meta`, `emacs-ctlx`, `vi`, `vi-move`, `vi-command`, and `vi-insert`. `vi` is equivalent to `vi-command` (`vi-move` is also a synonym); `emacs` is equivalent to `emacs-standard`. Applications may add additional names. The default value is `emacs`. The value of the `editing-mode` variable also affects the default keymap. 内置`keymap``emacs``emacs-standard``emacs-meta``emacs-ctlx``vi``vi-move``vi-command``vi-insert``vi` 等价于 `vi-command`（`vi-move`同义词）;`emacs` 等同于 `emacs-standard`默认值为 `emacs``editing-mode`设置 Readline 对键绑定命令的当前键盘映射的想法。 名称包括 ， ， ， ， ， ， 和 。 也是 。 应用程序可能会添加其他名称。 。 变量的值也会影响 默认键盘映射。

`keyseq-timeout`

Specifies the duration Readline will wait for a character when reading an ambiguous key sequence (one that can form a complete key sequence using the input read so far, or can take additional input to complete a longer key sequence). If no input is received within the timeout, Readline will use the shorter but complete key sequence. Readline uses this value to determine whether or not input is available on the current input source (`rl_instream` by default). The value is specified in milliseconds, so a value of 1000 means that Readline will wait one second for additional input. If this variable is set to a value less than or equal to zero, or to a non-numeric value, Readline will wait until another key is pressed to decide which key sequence to complete. The default value is `500`. 在当前输入源上可用（默认`rl_instream`默认值为 `500`指定读取行在读取字符时等待字符的持续时间 模棱两可的键序列（可以使用 输入读取到此为止，或者可以采取额外的输入来完成更长的输入 键序列）。 如果在超时内未收到任何输入，Readline 将使用较短的 但完整的按键序列。 Readline 使用此值来确定输入是否是 ）。 该值以毫秒为单位指定，因此值 1000 表示 Readline 将等待一秒钟以等待其他输入。 如果此变量设置为小于或等于零的值，或者设置为 非数值，Readline 将等待，直到按下另一个键 确定要完成的密钥序列。 。

`mark-directories`

If set to ‘on’, completed directory names have a slash appended. The default is ‘on’. 如果设置为“on附加。 默认值为“on”，则完成的目录名称带有斜杠 ”。

`mark-modified-lines`

This variable, when set to ‘on’, causes Readline to display an asterisk (‘\*’) at the start of history lines which have been modified. This variable is ‘off’ by default. 当此变量设置为“on星号 （'\*默认情况下，此变量为“off”时，会导致 Readline 显示 '） 在已修改的历史行的开头。 ”。

`mark-symlinked-directories`

If set to ‘on’, completed names which are symbolic links to directories have a slash appended (subject to the value of `mark-directories`). The default is ‘off’. 如果设置为“on`mark-directories`默认值为“off”，则为符号链接的已完成名称 to 目录附加一个斜杠（受 ）。 ”。

`match-hidden-files`

This variable, when set to ‘on’, causes Readline to match files whose names begin with a ‘.’ (hidden files) when performing filename completion. If set to ‘off’, the leading ‘.’ must be supplied by the user in the filename to be completed. This variable is ‘on’ by default. 当此变量设置为“on名称以“.如果设置为“off”，则前导“.默认情况下，此变量为“on”时，会导致 Readline 匹配其 ”开头（隐藏文件）时执行文件名 完成。 ”必须是 由用户在要完成的文件名中提供。 ”。

If set to ‘on’, menu completion displays the common prefix of the list of possible completions (which may be empty) before cycling through the list. The default is ‘off’. 如果设置为“on列表。 默认值为“off”，则菜单完成将显示 循环之前可能的完成列表（可能是空的） ”。

`output-meta`

If set to ‘on’, Readline will display characters with the eighth bit set directly rather than as a meta-prefixed escape sequence. The default is ‘off’, but Readline will set it to ‘on’ if the locale contains eight-bit characters. This variable is dependent on the `LC_CTYPE` locale category, and may change if the locale is changed. 如果设置为“on默认值为“off”，但 Readline 会将其设置为“on此变量取决于`LC_CTYPE`”，Readline 将显示带有 第八位直接设置，而不是作为元前缀转义 序列。 ”，如果 区域设置包含八位字符。 区域设置类别，并且 如果区域设置更改，则可能会更改。

`page-completions`

If set to ‘on’, Readline uses an internal `more`\-like pager to display a screenful of possible completions at a time. This variable is ‘on’ by default. 如果设置为“on”，则 Readline 使用`more`默认情况下，此变量为“on像寻呼机 以一次显示可能完成的屏幕。 ”。

`print-completions-horizontally`

If set to ‘on’, Readline will display completions with matches sorted horizontally in alphabetical order, rather than down the screen. The default is ‘off’. 如果设置为“on默认值为“off”，Readline 将显示匹配项的完成 按字母顺序水平排序，而不是按屏幕向下排序。 ”。

`revert-all-at-newline`

If set to ‘on’, Readline will undo all changes to history lines before returning when `accept-line` is executed. By default, history lines may be modified and retain individual undo lists across calls to `readline()`. The default is ‘off’.

`show-all-if-ambiguous`

This alters the default behavior of the completion functions. If set to ‘on’, words which have more than one possible completion cause the matches to be listed immediately instead of ringing the bell. The default value is ‘off’. 设置为“on默认值为“off这将更改完成函数的默认行为。 如果 ”， 具有多个可能完成的单词会导致 比赛要立即列出，而不是按铃。 ”。

`show-all-if-unmodified`

This alters the default behavior of the completion functions in a fashion similar to show-all-if-ambiguous. If set to ‘on’, words which have more than one possible completion without any possible partial completion (the possible completions don’t share a common prefix) cause the matches to be listed immediately instead of ringing the bell. The default value is ‘off’. 一种类似于 show-all-if-ambiguous如果设置为“on默认值为“off这将更改 的时尚。 ”， 具有多个可能完成而没有任何完成的单词 可能的部分完成（可能的完成不共享 一个通用前缀）导致立即列出匹配项 敲响钟声。 ”。

`show-mode-in-prompt`

If set to ‘on’, add a string to the beginning of the prompt indicating the editing mode: emacs, vi command, or vi insertion. The mode strings are user-settable (e.g., emacs-mode-string). The default value is ‘off’. 如果设置为“on模式字符串是用户可设置的（例如，emacs-mode-string默认值为“off”，请在提示的开头添加一个字符串 指示编辑模式：emacs、vi 命令或 vi 插入。 ）。 ”。

`skip-completed-text`

If set to ‘on’, this alters the default completion behavior when inserting a single match into the line. It’s only active when performing completion in the middle of a word. If enabled, Readline does not insert characters from the completion that match characters after point in the word being completed, so portions of the word following the cursor are not duplicated. For instance, if this is enabled, attempting completion when the cursor is after the ‘e’ in ‘Makefile’ will result in ‘Makefile’ rather than ‘Makefilefile’, assuming there is a single possible completion. The default value is ‘off’. 如果设置为“on在“Makefile”中的“e”之后将产生“Makefile而不是“Makefilefile默认值为“off”，则在以下情况下会更改默认完成行为 将单个匹配项插入到行中。 它仅在以下情况下处于活动状态 在单词中间执行完成。 如果启用，Readline 不插入完成中与字符匹配的字符 在单词的点被完成之后，所以单词的部分 光标后面不重复。 例如，如果启用此功能，则在光标 ” ”，假设有一个可能的 完成。 ”。

`vi-cmd-mode-string`

If the show-mode-in-prompt variable is enabled, this string is displayed immediately before the last line of the primary prompt when vi editing mode is active and in command mode. The value is expanded like a key binding, so the standard set of meta- and control prefixes and backslash escape sequences is available. Use the ‘\\1’ and ‘\\2’ escapes to begin and end sequences of non-printing characters, which can be used to embed a terminal control sequence into the mode string. The default is ‘(cmd)’. 如果启用了 show-mode-in-prompt使用“\\1”和“\\2默认值为“(cmd) 变量， 此字符串紧接在主节点的最后一行之前显示 当 VI 编辑模式处于活动状态并处于命令模式时提示。 该值像 键绑定，因此 meta- 和 control 前缀的标准集和 反斜杠转义序列可用。 ”转义来开始和结束序列 非打印字符，可用于嵌入终端控件 序列到模式字符串中。 ”。

`vi-ins-mode-string`

If the show-mode-in-prompt variable is enabled, this string is displayed immediately before the last line of the primary prompt when vi editing mode is active and in insertion mode. The value is expanded like a key binding, so the standard set of meta- and control prefixes and backslash escape sequences is available. Use the ‘\\1’ and ‘\\2’ escapes to begin and end sequences of non-printing characters, which can be used to embed a terminal control sequence into the mode string. The default is ‘(ins)’. 如果启用了 show-mode-in-prompt使用“\\1”和“\\2默认值为 '(ins) 变量， 此字符串紧接在主节点的最后一行之前显示 当 VI 编辑模式处于活动状态并处于插入模式时提示。 该值像 键绑定，因此 meta- 和 control 前缀的标准集和 反斜杠转义序列可用。 ”转义来开始和结束序列 非打印字符，可用于嵌入终端控件 序列到模式字符串中。 '。

`visible-stats`

If set to ‘on’, a character denoting a file’s type is appended to the filename when listing possible completions. The default is ‘off’. 如果设置为“on完成。 默认值为“off”，则表示文件类型的字符 在可能的情况下附加到文件名 ”。

Key Bindings密钥绑定

The syntax for controlling key bindings in the init file is simple. First you need to find the name of the command that you want to change. The following sections contain tables of the command name, the default keybinding, if any, and a short description of what the command does. 用于控制 init 文件中的键绑定的语法是 简单。 首先，您需要找到命令的名称 想要改变。 以下各节包含该命令的表 name、默认键绑定（如果有）以及内容的简短说明 该命令确实如此。

Once you know the name of the command, simply place on a line in the init file the name of the key you wish to bind the command to, a colon, and then the name of the command. There can be no space between the key name and the colon – that will be interpreted as part of the key name. The name of the key can be expressed in different ways, depending on what you find most comfortable. 知道命令名称后，只需放在一行上即可 在 init 文件中，密钥的名称 您希望将命令绑定到冒号，然后是 命令。 键名和冒号之间不能有空格——这将是 解释为密钥名称的一部分。 密钥的名称可以用不同的方式表示，具体取决于 你觉得最舒服的。

In addition to command names, Readline allows keys to be bound to a string that is inserted when the key is pressed (a macro). 添加到按下该键时插入的字符串（macro除了命令名称之外，Readline 还允许绑定密钥 ）。

The `bind -p` command displays Readline function names and bindings in a format that can be put directly into an initialization file. See [Bash Builtin Commands](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins). bind \-p请参阅 [Bash 内置命令](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins) 命令显示 Readline 函数名称和 绑定的格式可以直接放入初始化文件中。 。

keyname: function-name or macrokeyname：函数名称或macro

keyname is the name of a key spelled out in English. For example: keyname 是用英文拼写的键的名称。 例如：

```
Control-u: universal-argument
Meta-Rubout: backward-kill-word
Control-o: "&gt; output"
```

In the example above, C-u is bound to the function `universal-argument`, M-DEL is bound to the function `backward-kill-word`, and C-o is bound to run the macro expressed on the right hand side (that is, to insert the text ‘\> output’ into the line). 在上面的示例中，C-u`universal-argument`M-DEL 绑定到`backward-kill-word`C-o'\> output 绑定到函数 ，并且 绑定要运行宏 在右侧表示（即插入文本 '到行中）。

A number of symbolic character names are recognized while processing this key binding syntax: DEL, ESC, ESCAPE, LFD, NEWLINE, RET, RETURN, RUBOUT, SPACE, SPC, and TAB. DELESCESCAPELFDNEWLINERETRETURNRUBOUTSPACESPCTAB许多符号字符名称被识别，而 处理此键绑定语法： ， ， ， 的， ， 的， ， ， 和 。

"keyseq": function-name or macro“keyseq”： 函数名称或macro

keyseq differs from keyname above in that strings denoting an entire key sequence can be specified, by placing the key sequence in double quotes. Some <small>GNU</small> Emacs style key escapes can be used, as in the following example, but the special character names are not recognized. keyseq 与上面的 keyname双引号中的键序列。 一些 <small>GNU</small> 的不同之处在于字符串 表示整个键序列可以通过以下方式指定 Emacs 样式键 可以使用转义，如以下示例所示，但 无法识别特殊字符名称。

```
"\C-u": universal-argument
"\C-x\C-r": re-read-init-file
"\e[11~": "Function Key 1"
```

In the above example, C-u is again bound to the function `universal-argument` (just as it was in the first example), ‘C-x C-r’ is bound to the function `re-read-init-file`, and ‘ESC \[ 1 1 ~’ is bound to insert the text ‘Function Key 1’. 在上面的例子中，C-u`universal-argument`'C-xC-r' 绑定到函数 `re-read-init-file`和 'ESC\[11~文本“Function Key 1 再次绑定到函数 （就像第一个例子一样）， ， ' 势必会插入 ”。

The following <small>GNU</small> Emacs style escape sequences are available when specifying key sequences: 以下 <small>GNU</small> Emacs 样式的转义序列在以下情况下可用 指定键序列：

`\C-`

control prefix 控件前缀

`\M-`

meta prefix 元前缀

`\e`

an escape character 逃脱角色

`\\`

backslash 反斜線

`\"`

", a double quotation mark “，双引号

`\'`

', a single quote or apostrophe '，单引号或撇号

In addition to the <small>GNU</small> Emacs style escape sequences, a second set of backslash escapes is available: 除了 <small>GNU</small> Emacs 风格的转义序列之外，第二个 一组反斜杠转义可用：

`\a`

alert (bell) 警报（铃铛）

`\b`

backspace 退格键

`\d`

delete 删除

`\f`

form feed 表单提要

`\n`

newline 换行

`\r`

carriage return 回车

`\t`

horizontal tab 水平选项卡

`\v`

vertical tab 垂直选项卡

`\nnn`\\nnn

the eight-bit character whose value is the octal value nnn (one to three digits) 值为八进制值 nnn 的八位字符 （一位至三位数字）

`\xHH`\\xHH

the eight-bit character whose value is the hexadecimal value HH (one or two hex digits) 值为十六进制值 HH 的八位字符 （一个或两个十六进制数字）

When entering the text of a macro, single or double quotes must be used to indicate a macro definition. Unquoted text is assumed to be a function name. In the macro body, the backslash escapes described above are expanded. Backslash will quote any other character in the macro text, including ‘"’ and ‘'’. For example, the following binding will make ‘C-x \\’ insert a single ‘\\’ into the line: 包括 "' 和 ''例如，以下绑定将使“C-x在行中插入一个“\\输入宏文本时，单引号或双引号必须 用于指示宏定义。 不带引号的文本被假定为函数名称。 在宏主体中，上述反斜杠转义将展开。 反斜杠将引用宏文本中的任何其他字符， '。 \\” ”：

___

#### 8.3.2 Conditional Init Constructs8.3.2 条件初始化构造

Readline implements a facility similar in spirit to the conditional compilation features of the C preprocessor which allows key bindings and variable settings to be performed as the result of tests. There are four parser directives used. Readline 实现了一个在精神上类似于条件 C 预处理器的编译功能，允许密钥 要作为结果执行的绑定和变量设置 的测试。 使用了四个解析器指令。

`$if`

The `$if` construct allows bindings to be made based on the editing mode, the terminal being used, or the application using Readline. The text of the test, after any comparison operator, extends to the end of the line; unless otherwise noted, no characters are required to isolate it. `$if` 构造允许基于 编辑模式、正在使用的终端或使用的应用程序 阅读线。 测试的文本，经过任何比较运算符， 延伸到线的末端; 除非另有说明，否则不需要任何字符来隔离它。

`mode`

The `mode=` form of the `$if` directive is used to test whether Readline is in `emacs` or `vi` mode. This may be used in conjunction with the ‘set keymap’ command, for instance, to set bindings in the `emacs-standard` and `emacs-ctlx` keymaps only if Readline is starting out in `emacs` mode. `$if`指令的 `mode=`Readline 是处于 `emacs` 模式还是 `vi`例如，使用“set keymap`emacs-standard` 和 `emacs-ctlx`Readline 以 `emacs` 形式用于测试 模式。 这可以结合使用 ”命令在 键盘映射仅在以下情况下 模式启动。

`term`

The `term=` form may be used to include terminal-specific key bindings, perhaps to bind the key sequences output by the terminal’s function keys. The word on the right side of the ‘\=’ is tested against both the full name of the terminal and the portion of the terminal name before the first ‘\-’. This allows `sun` to match both `sun` and `sun-cmd`, for instance. `term=`'\=第一个“\-允许 `sun` 匹配 `sun` 和 `sun-cmd` 形式可用于包括特定于终端的 键绑定，也许是为了绑定由 终端的功能键。 右侧的单词 ' 针对终端的全名和 ”之前的终端名称部分。 这 ， 例如。

`version`

The `version` test may be used to perform comparisons against specific Readline versions. The `version` expands to the current Readline version. The set of comparison operators includes ‘\=’ (and ‘\==’), ‘!=’, ‘<=’, ‘\>=’, ‘<’, and ‘\>’. The version number supplied on the right side of the operator consists of a major version number, an optional decimal point, and an optional minor version (e.g., ‘7.1’). If the minor version is omitted, it is assumed to be ‘0’. The operator may be separated from the string `version` and from the version number argument by whitespace. The following example sets a variable if the Readline version being used is 7.0 or newer: `version``version`'\=' （和 '\=='）， '!='， '<='， '\>='， '<和“\>次要版本（例如，“7.1假定为“0运算符可以与字符串`version`测试可用于执行比较 特定的 Readline 版本。 将扩展为当前的 Readline 版本。 比较运算符集包括 '， ”。 运算符右侧提供的版本号包括 主版本号、可选小数点和可选 ”）。如果省略次要版本，则 ”。 分离，并且 从空格的版本号参数。 以下示例设置一个变量，如果正在使用的 Readline 版本 是 7.0 或更高版本：

```
$if version &gt;= 7.0
set show-mode-in-prompt on
$endif
```

`application`

The application construct is used to include application-specific settings. Each program using the Readline library sets the application name, and you can test for a particular value. This could be used to bind key sequences to functions useful for a specific program. For instance, the following command adds a key sequence that quotes the current or previous word in Bash: application库设置application name构造用于包括 特定于应用程序的设置。 每个程序都使用 Readline ，您可以测试 特定值。 这可用于将关键序列绑定到对以下 一个特定的程序。 例如，以下命令添加一个 在 Bash 中引用当前或上一个单词的关键序列：

```
$if Bash
# Quote the current or previous word
"\C-xq": "\eb\"\ef\""
$endif
```

`variable`

The variable construct provides simple equality tests for Readline variables and values. The permitted comparison operators are ‘\=’, ‘\==’, and ‘!=’. The variable name must be separated from the comparison operator by whitespace; the operator may be separated from the value on the right hand side by whitespace. Both string and boolean variables may be tested. Boolean variables must be tested against the values on and off. The following example is equivalent to the `mode=emacs` test described above: variable允许的比较运算符为 '\='、'\==' 和 '!=针对 on 和 off以下示例等效于所描述的 `mode=emacs`结构为 Readline 提供简单的相等性检验 变量和值。 '。 变量名必须与比较运算符分开 空白;运算符可以与右侧的值分开 旁边是空格。 字符串变量和布尔变量都可以测试。布尔变量必须是 的值进行了测试。 测试 以上：

```
$if editing-mode == emacs
set show-mode-in-prompt on
$endif
```

`$endif`

This command, as seen in the previous example, terminates an `$if` command. `$if`如上一示例所示，此命令将终止 命令。

`$else`

Commands in this branch of the `$if` directive are executed if the test fails. 如果出现以下情况，则执行 `$if` 指令的此分支中的命令 测试失败。

`$include`

This directive takes a single filename as an argument and reads commands and bindings from that file. For example, the following directive reads from /etc/inputrc: 例如，以下指令从 /etc/inputrc此指令采用单个文件名作为参数并读取命令 以及该文件中的绑定。 读取：

___

#### 8.3.3 Sample Init File8.3.3 示例加热文件

Here is an example of an inputrc file. This illustrates key binding, variable assignment, and conditional syntax. 下面是 inputrc 文件的示例。 这说明了关键 绑定、变量赋值和条件语法。

```
# This file controls the behaviour of line input editing for
# programs that use the GNU Readline library.  Existing
# programs include FTP, Bash, and GDB.
#
# You can re-read the inputrc file with C-x C-r.
# Lines beginning with '#' are comments.
#
# First, include any system-wide bindings and variable
# assignments from /etc/Inputrc
$include /etc/Inputrc

#
# Set various bindings for emacs mode.

set editing-mode emacs 

$if mode=emacs

Meta-Control-h:backward-kill-wordText after the function name is ignored

#
# Arrow keys in keypad mode
#
#"\M-OD":        backward-char
#"\M-OC":        forward-char
#"\M-OA":        previous-history
#"\M-OB":        next-history
#
# Arrow keys in ANSI mode
#
"\M-[D":        backward-char
"\M-[C":        forward-char
"\M-[A":        previous-history
"\M-[B":        next-history
#
# Arrow keys in 8 bit keypad mode
#
#"\M-\C-OD":       backward-char
#"\M-\C-OC":       forward-char
#"\M-\C-OA":       previous-history
#"\M-\C-OB":       next-history
#
# Arrow keys in 8 bit ANSI mode
#
#"\M-\C-[D":       backward-char
#"\M-\C-[C":       forward-char
#"\M-\C-[A":       previous-history
#"\M-\C-[B":       next-history

C-q: quoted-insert

$endif

# An old-style binding.  This happens to be the default.
TAB: complete

# Macros that are convenient for shell interaction
$if Bash
# edit the path
"\C-xp": "PATH=${PATH}\e\C-e\C-a\ef\C-f"
# prepare to type a quoted word --
# insert open and close double quotes
# and move to just after the open quote
"\C-x\"": "\"\"\C-b"
# insert a backslash (testing backslash escapes
# in sequences and macros)
"\C-x\\": "\\"
# Quote the current or previous word
"\C-xq": "\eb\"\ef\""
# Add a binding to refresh the line, which is unbound
"\C-xr": redraw-current-line
# Edit variable on current line.
"\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
$endif

# use a visible bell if one is available
set bell-style visible

# don't strip characters to 7 bits when reading
set input-meta on

# allow iso-latin1 characters to be inserted rather
# than converted to prefix-meta sequences
set convert-meta off

# display characters with the eighth bit set directly
# rather than as meta-prefixed characters
set output-meta on

# if there are 150 or more possible completions for a word,
# ask whether or not the user wants to see all of them
set completion-query-items 150

# For FTP
$if Ftp
"\C-xg": "get \M-?"
"\C-xt": "put \M-?"
"\M-.": yank-last-arg
$endif
```

___

### 8.4 Bindable Readline Commands8.4 可绑定的 readline 命令

This section describes Readline commands that may be bound to key sequences. You can list your key bindings by executing `bind -P` or, for a more terse format, suitable for an inputrc file, `bind -p`. (See [Bash Builtin Commands](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins).) Command names without an accompanying key sequence are unbound by default. bind \-Pinputrc 文件，bind \-p。 （请参阅 [Bash 内置命令](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins)本节介绍可能绑定到 key 的 Readline 命令 序列。 您可以通过执行以下命令来列出键绑定 或者，对于更简洁的格式，适用于 。 默认情况下，没有附带键序列的命令名称是取消绑定的。

In the following descriptions, _point_ refers to the current cursor position, and _mark_ refers to a cursor position saved by the `set-mark` command. The text between the point and mark is referred to as the _region_. 在下面的描述中，_point_位置，_标记_`set-mark`点和标记之间的文本称为_区域_ 是指当前光标 是指由 命令。 。

-   [Commands For Moving移动命令](https://www.gnu.org/software/bash/manual/bash.html#Commands-For-Moving)
-   [Commands For Manipulating The History用于操作历史记录的命令](https://www.gnu.org/software/bash/manual/bash.html#Commands-For-History)
-   [Commands For Changing Text更改文本的命令](https://www.gnu.org/software/bash/manual/bash.html#Commands-For-Text)
-   [Killing And Yanking杀戮和拉扯](https://www.gnu.org/software/bash/manual/bash.html#Commands-For-Killing)
-   [Specifying Numeric Arguments指定数值参数](https://www.gnu.org/software/bash/manual/bash.html#Numeric-Arguments)
-   [Letting Readline Type For You让 Readline 为您打字](https://www.gnu.org/software/bash/manual/bash.html#Commands-For-Completion)
-   [Keyboard Macros键盘宏](https://www.gnu.org/software/bash/manual/bash.html#Keyboard-Macros)
-   [Some Miscellaneous Commands一些杂项命令](https://www.gnu.org/software/bash/manual/bash.html#Miscellaneous-Commands)

___

#### 8.4.1 Commands For Moving8.4.1 移动命令

`beginning-of-line (C-a)`

Move to the start of the current line. 移动到当前行的开头。

`end-of-line (C-e)`

Move to the end of the line. 移动到行的末尾。

`forward-char (C-f)`

Move forward a character. 向前移动一个字符。

`backward-char (C-b)`

Move back a character. 向后移动一个字符。

`forward-word (M-f)`

Move forward to the end of the next word. Words are composed of letters and digits. 前进到下一个单词的末尾。 单词由字母和数字组成。

`backward-word (M-b)`

Move back to the start of the current or previous word. Words are composed of letters and digits. 移回当前或上一个单词的开头。 单词由字母和数字组成。

`shell-forward-word (M-C-f)`

Move forward to the end of the next word. Words are delimited by non-quoted shell metacharacters. 前进到下一个单词的末尾。 单词由不带引号的 shell 元字符分隔。

`shell-backward-word (M-C-b)`

Move back to the start of the current or previous word. Words are delimited by non-quoted shell metacharacters. 移回当前或上一个单词的开头。 单词由不带引号的 shell 元字符分隔。

`previous-screen-line ()`

Attempt to move point to the same physical screen column on the previous physical screen line. This will not have the desired effect if the current Readline line does not take up more than one physical line or if point is not greater than the length of the prompt plus the screen width. 尝试将点移动到上一个物理屏幕列上的同一物理屏幕列 物理屏幕线。如果电流 读取线不占用多条物理线，或者如果点不占用 大于提示的长度加上屏幕宽度。

`next-screen-line ()`

Attempt to move point to the same physical screen column on the next physical screen line. This will not have the desired effect if the current Readline line does not take up more than one physical line or if the length of the current Readline line is not greater than the length of the prompt plus the screen width. 尝试将指向移动到下一个物理屏幕列的同一物理屏幕列 物理屏幕线。如果电流 readline 行不占用多于一条物理线，或者如果长度 当前 Readline 行的长度不大于提示的长度 加上屏幕宽度。

`clear-display (M-C-l)`

Clear the screen and, if possible, the terminal’s scrollback buffer, then redraw the current line, leaving the current line at the top of the screen. 清除屏幕，如果可能，清除终端的回滚缓冲区， 然后重新绘制当前线， 将当前行保留在屏幕顶部。

`clear-screen (C-l)`

Clear the screen, then redraw the current line, leaving the current line at the top of the screen. 清除屏幕， 然后重新绘制当前线， 将当前行保留在屏幕顶部。

`redraw-current-line ()`

Refresh the current line. By default, this is unbound. 刷新当前行。 默认情况下，这是未绑定的。

___

#### 8.4.2 Commands For Manipulating The History8.4.2 操作历史记录的命令

`accept-line (Newline or Return)`

Accept the line regardless of where the cursor is. If this line is non-empty, add it to the history list according to the setting of the `HISTCONTROL` and `HISTIGNORE` variables. If this line is a modified history line, then restore the history line to its original state. `HISTCONTROL` 和 `HISTIGNORE`无论光标位于何处，都接受该行。 如果此行是 非空，根据 变量。 如果此行是修改后的历史记录行，则恢复历史记录行 恢复到其原始状态。

`previous-history (C-p)`

Move ‘back’ through the history list, fetching the previous command. 在历史记录列表中“向后”移动，获取上一个命令。

`next-history (C-n)`

Move ‘forward’ through the history list, fetching the next command. 在历史记录列表中“向前”移动，获取下一个命令。

`beginning-of-history (M-<)`

Move to the first line in the history. 移动到历史记录中的第一行。

`end-of-history (M->)`

Move to the end of the input history, i.e., the line currently being entered. 移动到输入历史记录的末尾，即当前行 正在输入。

`reverse-search-history (C-r)`

Search backward starting at the current line and moving ‘up’ through the history as necessary. This is an incremental search. This command sets the region to the matched text and activates the mark. 从当前行开始向后搜索，然后“向上”移动 必要时的历史。 这是增量搜索。 此命令将区域设置为匹配的文本并激活标记。

`forward-search-history (C-s)`

Search forward starting at the current line and moving ‘down’ through the history as necessary. This is an incremental search. This command sets the region to the matched text and activates the mark. 从当前行开始向前搜索，然后“向下”移动 必要时的历史。 这是增量搜索。 此命令将区域设置为匹配的文本并激活标记。

`non-incremental-reverse-search-history (M-p)`

Search backward starting at the current line and moving ‘up’ through the history as necessary using a non-incremental search for a string supplied by the user. The search string may match anywhere in a history line. 从当前行开始向后搜索，然后“向上”移动 必要时使用非增量搜索浏览历史记录 对于用户提供的字符串。 搜索字符串可能与历史记录行中的任意位置匹配。

`non-incremental-forward-search-history (M-n)`

Search forward starting at the current line and moving ‘down’ through the history as necessary using a non-incremental search for a string supplied by the user. The search string may match anywhere in a history line. 从当前行开始向前搜索并“向下”移动 必要时使用非增量搜索浏览历史记录 对于用户提供的字符串。 搜索字符串可能与历史记录行中的任意位置匹配。

`history-search-forward ()`

Search forward through the history for the string of characters between the start of the current line and the point. The search string must match at the beginning of a history line. This is a non-incremental search. By default, this command is unbound. 在历史记录中向前搜索字符串 在当前线的起点和点之间。 搜索字符串必须与历史记录行的开头匹配。 这是非增量搜索。 默认情况下，此命令处于未绑定状态。

`history-search-backward ()`

Search backward through the history for the string of characters between the start of the current line and the point. The search string must match at the beginning of a history line. This is a non-incremental search. By default, this command is unbound. 在历史记录中向后搜索字符串 在当前线的起点和点之间。 搜索字符串必须与历史记录行的开头匹配。 这是非增量搜索。 默认情况下，此命令处于未绑定状态。

`history-substring-search-forward ()`

Search forward through the history for the string of characters between the start of the current line and the point. The search string may match anywhere in a history line. This is a non-incremental search. By default, this command is unbound. 在历史记录中向前搜索字符串 在当前线的起点和点之间。 搜索字符串可能与历史记录行中的任意位置匹配。 这是非增量搜索。 默认情况下，此命令处于未绑定状态。

`history-substring-search-backward ()`

Search backward through the history for the string of characters between the start of the current line and the point. The search string may match anywhere in a history line. This is a non-incremental search. By default, this command is unbound. 在历史记录中向后搜索字符串 在当前线的起点和点之间。 搜索字符串可能与历史记录行中的任意位置匹配。 这是非增量搜索。 默认情况下，此命令处于未绑定状态。

`yank-nth-arg (M-C-y)`

Insert the first argument to the previous command (usually the second word on the previous line) at point. With an argument n, insert the nth word from the previous command (the words in the previous command begin with word 0). A negative argument inserts the nth word from the end of the previous command. Once the argument n is computed, the argument is extracted as if the ‘!n’ history expansion had been specified. 使用参数 n插入上一个命令中的n插入上一个命令末尾的n计算参数 n好像“！n将第一个参数插入到上一个命令（通常 上一行的第二个单词）在点上。 ， 个单词（单词 在上一个命令中，以单词 0 开头。 否定论点 个单词。 后，将提取参数 ' 历史扩展已指定。

`yank-last-arg (M-. or M-_)`

Insert last argument to the previous command (the last word of the previous history entry). With a numeric argument, behave exactly like `yank-nth-arg`. Successive calls to `yank-last-arg` move back through the history list, inserting the last word (or the word specified by the argument to the first call) of each line in turn. Any numeric argument supplied to these successive calls determines the direction to move through the history. A negative argument switches the direction through the history (back or forward). The history expansion facilities are used to extract the last argument, as if the ‘!$’ history expansion had been specified. 使用数字参数时，行为与 `yank-nth-arg`对 `yank-last-arg`就好像指定了 '!$将最后一个参数插入到上一个命令中（最后一个单词 以前的历史条目）。 完全相同。 的连续调用会回到历史记录中 列表，插入最后一个单词（或参数指定的单词 第一次调用）依次对每行进行。 提供给这些连续调用的任何数值参数确定 在历史中前进的方向。 否定论点切换 历史记录的方向（向后或向前）。 历史扩展工具用于提取最后一个参数， ' 历史扩展一样。

`operate-and-get-next (C-o)`

Accept the current line for return to the calling application as if a newline had been entered, and fetch the next line relative to the current line from the history for editing. A numeric argument, if supplied, specifies the history entry to use instead of the current line. 接受当前行以返回到调用应用程序，就好像 已输入换行符， 并从历史记录中获取相对于当前行的下一行 用于编辑。 数值参数（如果提供）指定要改用的历史记录条目 的当前行。

`fetch-history ()`

With a numeric argument, fetch that entry from the history list and make it the current line. Without an argument, move back to the first entry in the history list. 使用数值参数，从历史记录列表中获取该条目 并使其成为当前行。 如果没有参数，请返回到历史记录列表中的第一个条目。

___

#### 8.4.3 Commands For Changing Text8.4.3 更改文本的命令

`_end-of-file_ (usually C-d)`_文件末_尾（通常为 C-d）

The character indicating end-of-file as set, for example, by `stty`. If this character is read when there are no characters on the line, and point is at the beginning of the line, Readline interprets it as the end of input and returns <small>EOF</small>. `stty`将其解释为输入的结尾并返回 <small>EOF</small>指示文件结尾的字符，例如，由 。 如果在没有字符的情况下读取此字符 在线上，点位于行的开头，Readline 。

`delete-char (C-d)`

Delete the character at point. If this function is bound to the same character as the tty <small>EOF</small> character, as C-d commonly is, see above for the effects. 与 tty <small>EOF</small> 字符相同的字符，作为 C-d删除该点的字符。 如果此函数绑定到 通常是，效果见上文。

`backward-delete-char (Rubout)`

Delete the character behind the cursor. A numeric argument means to kill the characters instead of deleting them. 删除光标后面的字符。 数值参数意味着 杀死字符而不是删除它们。

`forward-backward-delete-char ()`

Delete the character under the cursor, unless the cursor is at the end of the line, in which case the character behind the cursor is deleted. By default, this is not bound to a key. 删除光标下的字符，除非光标位于 行尾，在这种情况下，光标后面的字符是 删除。 默认情况下，这不绑定到密钥。

`quoted-insert (C-q or C-v)`

Add the next character typed to the line verbatim. This is how to insert key sequences like C-q, for example. 例如，如何插入 C-q将键入的下一个字符逐字添加到该行。 这是 等关键序列。

`self-insert (a, b, A, 1, !, …)`

Insert yourself. 插入自己。

`bracketed-paste-begin ()`

This function is intended to be bound to the "bracketed paste" escape sequence sent by some terminals, and such a binding is assigned by default. It allows Readline to insert the pasted text as a single unit without treating each character as if it had been read from the keyboard. The characters are inserted as if each one was bound to `self-insert` instead of executing any editing commands. 入，就好像每个都被绑定到`self-insert`此函数旨在绑定到“括号粘贴”转义 序列由某些终端发送，并且默认分配此类绑定。 它允许 Readline 将粘贴的文本作为一个单元插入，而无需处理 每个字符都像是从键盘上读出来的一样。 人物 而不是 执行任何编辑命令。

Bracketed paste sets the region (the characters between point and the mark) to the inserted text. It uses the concept of an _active mark_: when the mark is active, Readline redisplay uses the terminal’s standout mode to denote the region. 添加到插入的文本中。它使用_有效标记_括号中的粘贴设置区域（点和标记之间的字符） 的概念：当 标记处于活动状态，Readline 重新显示使用终端的突出模式来 表示区域。

`transpose-chars (C-t)`

Drag the character before the cursor forward over the character at the cursor, moving the cursor forward as well. If the insertion point is at the end of the line, then this transposes the last two characters of the line. Negative arguments have no effect. 将光标前的字符向前拖动 光标处的字符，移动 光标也向前。 如果插入点 在行的末尾，那么这个 转置行的最后两个字符。 否定的论点是无效的。

`transpose-words (M-t)`

Drag the word before point past the word after point, moving point past that word as well. If the insertion point is at the end of the line, this transposes the last two words on the line. 将点前的单词拖过点后点的单词， 也越过这个词。 如果插入点位于行的末尾，则进行转置 行上的最后两个字。

`upcase-word (M-u)`

Uppercase the current (or following) word. With a negative argument, uppercase the previous word, but do not move the cursor. 当前（或后续）单词大写。 有了否定的论点， 将前一个单词大写，但不要移动光标。

`downcase-word (M-l)`

Lowercase the current (or following) word. With a negative argument, lowercase the previous word, but do not move the cursor. 当前（或后续）单词小写。 有了否定的论点， 将前一个单词小写，但不要移动光标。

`capitalize-word (M-c)`

Capitalize the current (or following) word. With a negative argument, capitalize the previous word, but do not move the cursor. 将当前（或后面）的单词大写。 有了否定的论点， 将前一个单词大写，但不要移动光标。

`overwrite-mode ()`

Toggle overwrite mode. With an explicit positive numeric argument, switches to overwrite mode. With an explicit non-positive numeric argument, switches to insert mode. This command affects only `emacs` mode; `vi` mode does overwrite differently. Each call to `readline()` starts in insert mode. `emacs`模式;`vi`每次对 `readline()`切换覆盖模式。 使用显式的正数值参数， 切换到覆盖模式。 使用显式非正数值 参数，切换到插入模式。 此命令仅影响 模式会以不同的方式覆盖。 的调用都以插入模式启动。

In overwrite mode, characters bound to `self-insert` replace the text at point rather than pushing the text to the right. Characters bound to `backward-delete-char` replace the character before point with a space. 在覆盖模式下，绑定到`self-insert`绑定到 `backward-delete-char`的字符将替换 文本在点上，而不是将文本推到右边。 的字符将替换该字符 在用空格点之前。

By default, this command is unbound. 默认情况下，此命令处于未绑定状态。

___

#### 8.4.4 Killing And Yanking8.4.4 杀戮和拉扯

`kill-line (C-k)`

Kill the text from point to the end of the line. With a negative numeric argument, kill backward from the cursor to the beginning of the current line. 从点到行尾终止文本。 使用负数参数，从光标向后终止 当前行的开头。

`backward-kill-line (C-x Rubout)`

Kill backward from the cursor to the beginning of the current line. With a negative numeric argument, kill forward from the cursor to the end of the current line. 从光标向后终止到当前行的开头。 使用负数参数，从光标向前 kill 到 当前行的末尾。

`unix-line-discard (C-u)`

Kill backward from the cursor to the beginning of the current line. 从光标向后终止到当前行的开头。

`kill-whole-line ()`

Kill all characters on the current line, no matter where point is. By default, this is unbound. 杀死当前行上的所有角色，无论点在哪里。 默认情况下，这是未绑定的。

`kill-word (M-d)`

Kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as `forward-word`. 单词边界与`forward-word`从点到当前单词的末尾，或者如果在 单词，到下一个单词的末尾。 相同。

`backward-kill-word (M-DEL)`向后杀戮字 （M-DEL）

Kill the word behind point. Word boundaries are the same as `backward-word`. 单词边界与`backward-word`扼杀点后面的字。 相同。

`shell-kill-word (M-C-d)`

Kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as `shell-forward-word`. 字边界与 `shell-forward-word`从点到当前单词的末尾，或者如果在 单词，到下一个单词的末尾。 相同。

`shell-backward-kill-word ()`

Kill the word behind point. Word boundaries are the same as `shell-backward-word`. 单词边界与 `shell-backward-word`扼杀点后面的字。 相同。

`shell-transpose-words (M-C-t)`

Drag the word before point past the word after point, moving point past that word as well. If the insertion point is at the end of the line, this transposes the last two words on the line. Word boundaries are the same as `shell-forward-word` and `shell-backward-word`. 单词边界与 `shell-forward-word``shell-backward-word`将点前的单词拖过点后点的单词， 也越过这个词。 如果插入点位于行的末尾，则进行转置 行上的最后两个字。 和 。

`unix-word-rubout (C-w)`

Kill the word behind point, using white space as a word boundary. The killed text is saved on the kill-ring. 删除点后面的单词，使用空格作为单词边界。 被杀死的文本保存在杀戮环上。

`unix-filename-rubout ()`

Kill the word behind point, using white space and the slash character as the word boundaries. The killed text is saved on the kill-ring. 使用空格和斜杠字符删除点后面的单词 作为边界这个词。 被杀死的文本保存在杀戮环上。

`delete-horizontal-space ()`

Delete all spaces and tabs around point. By default, this is unbound. 删除点周围的所有空格和制表符。 默认情况下，这是未绑定的。

`kill-region ()`

Kill the text in the current region. By default, this command is unbound. 终止当前区域中的文本。 默认情况下，此命令处于未绑定状态。

`copy-region-as-kill ()`

Copy the text in the region to the kill buffer, so it can be yanked right away. By default, this command is unbound. 将该区域中的文本复制到 kill 缓冲区，以便可以将其拉出 马上。 默认情况下，此命令处于未绑定状态。

`copy-backward-word ()`

Copy the word before point to the kill buffer. The word boundaries are the same as `backward-word`. By default, this command is unbound. “边界”一词与`backward-word`将单词 before 指向 kill 缓冲区。 相同。 默认情况下，此命令处于未绑定状态。

`copy-forward-word ()`

Copy the word following point to the kill buffer. The word boundaries are the same as `forward-word`. By default, this command is unbound. “边界”一词与`forward-word`将单词 following point 复制到 kill 缓冲区。 相同。 默认情况下，此命令处于未绑定状态。

`yank (C-y)`

Yank the top of the kill ring into the buffer at point. 将杀伤环的顶部拉入缓冲区。

`yank-pop (M-y)`

Rotate the kill-ring, and yank the new top. You can only do this if the prior command is `yank` or `yank-pop`. 先验命令是 `yank` 或 `yank-pop`旋转杀戮环，然后拉动新的顶部。 只有在以下情况下才能执行此操作 。

___

#### 8.4.5 Specifying Numeric Arguments8.4.5 指定数值参数

`digit-argument (M-0, M-1, … M--)`数字参数 （M-0， M-1， ...M--）

Add this digit to the argument already accumulating, or start a new argument. M-- starts a negative argument. 论点。 M--将此数字添加到已累积的参数中，或开始新的参数 开始否定论点。

`universal-argument ()`

This is another way to specify an argument. If this command is followed by one or more digits, optionally with a leading minus sign, those digits define the argument. If the command is followed by digits, executing `universal-argument` again ends the numeric argument, but is otherwise ignored. As a special case, if this command is immediately followed by a character that is neither a digit nor minus sign, the argument count for the next command is multiplied by four. The argument count is initially one, so executing this function the first time makes the argument count four, a second time makes the argument count sixteen, and so on. By default, this is not bound to a key.

___

#### 8.4.6 Letting Readline Type For You8.4.6 为您输入 readline

`complete (TAB)`完成 （TAB）

Attempt to perform completion on the text before point. The actual completion performed is application-specific. Bash attempts completion treating the text as a variable (if the text begins with ‘$’), username (if the text begins with ‘~’), hostname (if the text begins with ‘@’), or command (including aliases and functions) in turn. If none of these produces a match, filename completion is attempted. 文本以“$'~'）、主机名（如果文本以“@尝试对点前的文本执行补全。 实际执行的完成是特定于应用程序的。 Bash 尝试完成，将文本视为变量（如果 ”开头）、用户名（如果文本以 ”开头），或者 命令（包括别名和函数）。 如果没有 其中产生匹配项，尝试文件名补全。

`possible-completions (M-?)`

List the possible completions of the text before point. When displaying completions, Readline sets the number of columns used for display to the value of `completion-display-width`, the value of the environment variable `COLUMNS`, or the screen width, in that order. 对于显示为 `completion-display-width`环境变量 `COLUMNS`在点之前列出文本的可能完成。 显示完成时，Readline 会设置使用的列数 的值，则 或屏幕宽度，按此顺序排列。

`insert-completions (M-*)`

Insert all completions of the text before point that would have been generated by `possible-completions`. 由`possible-completions`在将要完成的点之前插入文本的所有补全 生成。

Similar to `complete`, but replaces the word to be completed with a single match from the list of possible completions. Repeated execution of `menu-complete` steps through the list of possible completions, inserting each match in turn. At the end of the list of completions, the bell is rung (subject to the setting of `bell-style`) and the original text is restored. An argument of n moves n positions forward in the list of matches; a negative argument may be used to move backward through the list. This command is intended to be bound to TAB, but is unbound by default. 类似于 `complete`在列表中重复执行`menu-complete`（以`bell-style`参数 n 在列表中向前移动 n此命令旨在绑定到 TAB，但替换了 to be completed 一词 与可能完成列表中的单个匹配项。 步骤 可能的完成，依次插入每个匹配项。 在完成列表的末尾，钟声响起 设置为准） 并恢复原始文本。 个位置 火柴数量;否定论点可用于向后移动 通过列表。 ，但未绑定 默认情况下。

Identical to `menu-complete`, but moves backward through the list of possible completions, as if `menu-complete` had been given a negative argument. 与`menu-complete`可能的完成，就好像`menu-complete`相同，但在列表中向后移动 被赋予了 否定论点。

`delete-char-or-list ()`

Deletes the character under the cursor if not at the beginning or end of the line (like `delete-char`). If at the end of the line, behaves identically to `possible-completions`. This command is unbound by default. 行尾（如 `delete-char``possible-completions`删除光标下的字符（如果不是在开头或 ）。 如果在行的末尾，则行为与 。 默认情况下，此命令处于未绑定状态。

`complete-filename (M-/)`

Attempt filename completion on the text before point. 尝试在点前的文本上完成文件名。

`possible-filename-completions (C-x /)`

List the possible completions of the text before point, treating it as a filename. 在点之前列出文本的可能完成， 将其视为文件名。

`complete-username (M-~)`

Attempt completion on the text before point, treating it as a username. 尝试在点之前完成文本，处理 它作为用户名。

`possible-username-completions (C-x ~)`

List the possible completions of the text before point, treating it as a username. 在点之前列出文本的可能完成， 将其视为用户名。

`complete-variable (M-$)`

Attempt completion on the text before point, treating it as a shell variable. 尝试在点之前完成文本，处理 它作为 shell 变量。

`possible-variable-completions (C-x $)`

List the possible completions of the text before point, treating it as a shell variable. 在点之前列出文本的可能完成， 将其视为 shell 变量。

`complete-hostname (M-@)`

Attempt completion on the text before point, treating it as a hostname. 尝试在点之前完成文本，处理 它作为主机名。

`possible-hostname-completions (C-x @)`

List the possible completions of the text before point, treating it as a hostname. 在点之前列出文本的可能完成， 将其视为主机名。

`complete-command (M-!)`

Attempt completion on the text before point, treating it as a command name. Command completion attempts to match the text against aliases, reserved words, shell functions, shell builtins, and finally executable filenames, in that order. 尝试在点之前完成文本，处理 它作为命令名称。 命令完成尝试 将文本与别名、保留字、shell 进行匹配 函数、shell 内置函数，最后是可执行文件名， 按此顺序。

`possible-command-completions (C-x !)`

List the possible completions of the text before point, treating it as a command name. 在点之前列出文本的可能完成， 将其视为命令名称。

`dynamic-complete-history (M-TAB)`动态完整历史记录 （M-TAB）

Attempt completion on the text before point, comparing the text against lines from the history list for possible completion matches. 尝试在点之前完成文本，比较 与历史记录列表中的行相对应的文本 完成匹配。

`dabbrev-expand ()`

Attempt menu completion on the text before point, comparing the text against lines from the history list for possible completion matches. 尝试在点前的文本上完成菜单，比较 与历史记录列表中的行相对应的文本 完成匹配。

`complete-into-braces (M-{)`

Perform filename completion and insert the list of possible completions enclosed within braces so the list is available to the shell (see [Brace Expansion](https://www.gnu.org/software/bash/manual/bash.html#Brace-Expansion)). （请参阅[大括号扩展](https://www.gnu.org/software/bash/manual/bash.html#Brace-Expansion)执行文件名补全并插入可能的补全列表 括在大括号内，以便该列表可供shell使用 ）。

___

#### 8.4.7 Keyboard Macros8.4.7 键盘宏

`start-kbd-macro (C-x ()`

Begin saving the characters typed into the current keyboard macro. 开始保存键入到当前键盘宏中的字符。

`end-kbd-macro (C-x ))`

Stop saving the characters typed into the current keyboard macro and save the definition. 停止保存键入到当前键盘宏中的字符 并保存定义。

`call-last-kbd-macro (C-x e)`

Re-execute the last keyboard macro defined, by making the characters in the macro appear as if typed at the keyboard. 重新执行定义的最后一个键盘宏，方法是使字符 在宏中，就像在键盘上键入一样。

`print-last-kbd-macro ()`

Print the last keyboard macro defined in a format suitable for the inputrc file. inputrc打印以适合 文件。

___

#### 8.4.8 Some Miscellaneous Commands8.4.8 一些杂项命令

`re-read-init-file (C-x C-r)`

Read in the contents of the inputrc file, and incorporate any bindings or variable assignments found there. 读取 inputrc 文件的内容，并合并 在那里找到的任何绑定或变量赋值。

`abort (C-g)`

Abort the current editing command and ring the terminal’s bell (subject to the setting of `bell-style`). `bell-style`中止当前编辑命令，然后 敲响终端的铃铛（取决于 ）。

`do-lowercase-version (M-A, M-B, M-x, …)`do-lowercase-version （M-A， M-B， x， ...）

If the metafied character x is upper case, run the command that is bound to the corresponding metafied lower case character. The behavior is undefined if x is already lower case. 如果元字符 x如果 x 为大写，请运行命令 绑定到相应的元化小写字符。 已为小写，则该行为未定义。

`prefix-meta (ESC)`前缀元 （ESC）

Metafy the next character typed. This is for keyboards without a meta key. Typing ‘ESC f’ is equivalent to typing M-f. 没有元键。 键入“ESCM-f元化键入的下一个字符。 这是为键盘准备的 f”等同于键入 。

`undo (C-_ or C-x C-u)`

Incremental undo, separately remembered for each line. 增量撤消，每行单独记住。

`revert-line (M-r)`

Undo all changes made to this line. This is like executing the `undo` command enough times to get back to the beginning. 撤消对此行所做的所有更改。 这就像执行`undo` 命令足够多的次数回到起点。

`tilde-expand (M-&)`

Perform tilde expansion on the current word. 对当前单词执行波浪号扩展。

`set-mark (C-@)`

Set the mark to the point. If a numeric argument is supplied, the mark is set to that position. 将标记设置到点上。 如果 提供 numeric 参数，将标记设置为该位置。

`exchange-point-and-mark (C-x C-x)`

Swap the point with the mark. The current cursor position is set to the saved position, and the old cursor position is saved as the mark. 用标记交换点。 当前光标位置设置为 保存的位置，旧的光标位置保存为标记。

`character-search (C-])`

A character is read and point is moved to the next occurrence of that character. A negative argument searches for previous occurrences. 读取一个字符，并将点移动到该字符的下一个匹配项 字符。 否定参数搜索以前的匹配项。

`character-search-backward (M-C-])`

A character is read and point is moved to the previous occurrence of that character. A negative argument searches for subsequent occurrences. 读取一个字符，并将点移动到前一个出现项 的那个性格。 否定参数搜索后续 事件。

`skip-csi-sequence ()`

Read enough characters to consume a multi-key sequence such as those defined for keys like Home and End. Such sequences begin with a Control Sequence Indicator (CSI), usually ESC-\[. If this sequence is bound to "\\e\[", keys producing such sequences will have no effect unless explicitly bound to a Readline command, instead of inserting stray characters into the editing buffer. This is unbound by default, but usually bound to ESC-\[. 读取足够多的字符以使用多键序列，例如这些字符 为 Home 和 End 等键定义。 此类序列以 控制序列指示器 （CSI），通常为 ESC-\[. 如果此序列是 绑定到“\\e\[”，生成此类序列的键将不起作用 除非显式绑定到 Readline 命令，而不是插入 杂散字符进入编辑缓冲区。 默认情况下，这是未绑定的， 但通常绑定到 ESC-\[.

Without a numeric argument, the value of the `comment-begin` variable is inserted at the beginning of the current line. If a numeric argument is supplied, this command acts as a toggle: if the characters at the beginning of the line do not match the value of `comment-begin`, the value is inserted, otherwise the characters in `comment-begin` are deleted from the beginning of the line. In either case, the line is accepted as if a newline had been typed. The default value of `comment-begin` causes this command to make the current line a shell comment. If a numeric argument causes the comment character to be removed, the line will be executed by the shell. 如果没有数值参数，`comment-begin`的 `comment-begin``comment-begin``comment-begin` 的值 变量插入到当前行的开头。 如果提供了数值参数，则此命令充当切换开关： 如果 行首的字符与值不匹配 ，否则插入该值 中的字符从开头删除 行。 无论哪种情况，该行都会被接受，就好像已键入换行符一样。 的默认值会导致此命令 使当前行成为 shell 注释。 如果数值参数导致删除注释字符，则该行 将由 shell 执行。

`dump-functions ()`

Print all of the functions and their key bindings to the Readline output stream. If a numeric argument is supplied, the output is formatted in such a way that it can be made part of an inputrc file. This command is unbound by default. inputrc将所有函数及其键绑定打印到 Readline 输出流。 如果提供了数值参数， 输出的格式使其可以成为一部分 文件。 默认情况下，此命令处于未绑定状态。

`dump-variables ()`

Print all of the settable variables and their values to the Readline output stream. If a numeric argument is supplied, the output is formatted in such a way that it can be made part of an inputrc file. This command is unbound by default. inputrc将所有可设置变量及其值打印到 Readline 输出流。 如果提供了数值参数， 输出的格式使其可以成为一部分 文件。 默认情况下，此命令处于未绑定状态。

`dump-macros ()`

Print all of the Readline key sequences bound to macros and the strings they output. If a numeric argument is supplied, the output is formatted in such a way that it can be made part of an inputrc file. This command is unbound by default. inputrc打印绑定到宏的所有 Readline 键序列和 他们输出的字符串。 如果提供了数值参数， 输出的格式使其可以成为一部分 文件。 默认情况下，此命令处于未绑定状态。

`spell-correct-word (C-x s)`

Perform spelling correction on the current word, treating it as a directory or filename, in the same way as the `cdspell` shell option. Word boundaries are the same as those used by `shell-forward-word`. 或 filename，与 `cdspell`单词边界与 `shell-forward-word`对当前单词执行拼写更正，将其视为目录 shell 选项相同。 使用的边界相同。

`glob-complete-word (M-g)`

The word before point is treated as a pattern for pathname expansion, with an asterisk implicitly appended. This pattern is used to generate a list of matching file names for possible completions. 点前的单词被视为路径名扩展的模式， 隐式附加星号。 此模式用于 为可能的完成生成匹配的文件名列表。

`glob-expand-word (C-x *)`

The word before point is treated as a pattern for pathname expansion, and the list of matching file names is inserted, replacing the word. If a numeric argument is supplied, a ‘\*’ is appended before pathname expansion. 如果提供了数值参数，则在前面附加一个“\*点前的单词被视为路径名扩展的模式， 并插入匹配的文件名列表，替换该单词。 ” 路径名扩展。

`glob-list-expansions (C-x g)`

The list of expansions that would have been generated by `glob-expand-word` is displayed, and the line is redrawn. If a numeric argument is supplied, a ‘\*’ is appended before pathname expansion. 将显示 `glob-expand-word`如果提供了数值参数，则在前面附加一个“\*本应生成的扩展列表 ，并重新绘制该线。 ” 路径名扩展。

`display-shell-version (C-x C-v)`

Display version information about the current instance of Bash. 显示有关当前 Bash 实例的版本信息。

`shell-expand-line (M-C-e)`

Expand the line as the shell does. This performs alias and history expansion as well as all of the shell word expansions (see [Shell Expansions](https://www.gnu.org/software/bash/manual/bash.html#Shell-Expansions)). 单词扩展（请参阅 [Shell 扩展](https://www.gnu.org/software/bash/manual/bash.html#Shell-Expansions)像 shell 一样展开线条。 这将执行别名和历史记录扩展以及所有 shell ）。

`history-expand-line (M-^)`

Perform history expansion on the current line. 对当前行执行历史记录扩展。

`magic-space ()`

Perform history expansion on the current line and insert a space (see [History Expansion](https://www.gnu.org/software/bash/manual/bash.html#History-Interaction)). （请参阅[历史扩展](https://www.gnu.org/software/bash/manual/bash.html#History-Interaction)对当前行执行历史记录扩展并插入空格 ）。

`alias-expand-line ()`

Perform alias expansion on the current line (see [Aliases](https://www.gnu.org/software/bash/manual/bash.html#Aliases)). 在当前行上执行别名扩展（请参阅[别名](https://www.gnu.org/software/bash/manual/bash.html#Aliases)）。

`history-and-alias-expand-line ()`

Perform history and alias expansion on the current line. 在当前行上执行历史记录和别名扩展。

`insert-last-argument (M-. or M-_)`

A synonym for `yank-last-arg`. `yank-last-arg` 的同义词。

`edit-and-execute-command (C-x C-e)`

Invoke an editor on the current command line, and execute the result as shell commands. Bash attempts to invoke `$VISUAL`, `$EDITOR`, and `emacs` as the editor, in that order. `$VISUAL`、`$EDITOR` 和 `emacs`在当前命令行上调用编辑器，并以 shell 格式执行结果 命令。 Bash 尝试调用 作为编辑，按此顺序。

___

### 8.5 Readline vi Mode8.5 Readline vi 模式

While the Readline library does not have a full set of `vi` editing functions, it does contain enough to allow simple editing of the line. The Readline `vi` mode behaves as specified in the <small>POSIX</small> standard. 虽然 Readline 库没有完整的 `vi`的行。 Readline `vi`<small>POSIX</small> 编辑功能，它确实包含足够的功能，允许简单的编辑 模式的行为与 标准。

In order to switch interactively between `emacs` and `vi` editing modes, use the ‘set -o emacs’ and ‘set -o vi’ commands (see [The Set Builtin](https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin)). The Readline default is `emacs` mode. 为了在 `emacs` 和 `vi`编辑模式，使用“set -o emacs”和“set -o vi命令（请参阅[内置设置](https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin)Readline 默认为 `emacs` 之间交互切换 ” ）。 模式。

When you enter a line in `vi` mode, you are already placed in ‘insertion’ mode, as if you had typed an ‘i’. Pressing ESC switches you into ‘command’ mode, where you can edit the text of the line with the standard `vi` movement keys, move to previous history lines with ‘k’ and subsequent lines with ‘j’, and so forth. 当您在 `vi`“插入”模式，就好像您输入了“i”一样。 按 ESC与标准 `vi`带有“k”的历史行和带有“j 模式下输入一行时，您已经进入了 键 将您切换到“命令”模式，您可以在其中编辑 移动键对齐，移至上一个 ”的后续行，以及 等等。

___

### 8.6 Programmable Completion8.6 可编程完成

When word completion is attempted for an argument to a command for which a completion specification (a compspec) has been defined using the `complete` builtin (see [Programmable Completion Builtins](https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion-Builtins)), the programmable completion facilities are invoked. 已定义完成规范（compspec使用`complete`内置组件（请参阅[可编程完成内置组件](https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion-Builtins)当尝试将参数用于命令的单词完成时 ） ）， 调用可编程完成工具。

First, the command name is identified. If a compspec has been defined for that command, the compspec is used to generate the list of possible completions for the word. If the command word is the empty string (completion attempted at the beginning of an empty line), any compspec defined with the \-E option to `complete` is used. If the command word is a full pathname, a compspec for the full pathname is searched for first. If no compspec is found for the full pathname, an attempt is made to find a compspec for the portion following the final slash. If those searches do not result in a compspec, any compspec defined with the \-D option to `complete` is used as the default. If there is no default compspec, Bash attempts alias expansion on the command word as a final resort, and attempts to find a compspec for the command word from any successful expansion 使用 \-E `complete`要`complete` \-D首先，确定命令名称。 如果已为该命令定义了 compspec，则 compspec 用于生成单词的可能完成列表。 如果命令字是空字符串（在 空行的开头），任何定义为 。 如果命令字是完整路径名，则完整路径名的 compspec 首先搜索 pathname。 如果未找到完整路径名的 compspec，则尝试 为最后一个斜杠之后的部分找到一个 compspec。 如果这些搜索未生成 compspec，则任何 compspec 都使用 选项用作默认值。 如果没有默认的 compspec，Bash 将尝试别名扩展 在命令字上作为最后的手段，并尝试找到一个 compspec 对于任何成功扩展的命令字

Once a compspec has been found, it is used to generate the list of matching words. If a compspec is not found, the default Bash completion described above (see [Letting Readline Type For You](https://www.gnu.org/software/bash/manual/bash.html#Commands-For-Completion)) is performed. 如上所述（请参阅 [Letting Readline Type For You](https://www.gnu.org/software/bash/manual/bash.html#Commands-For-Completion)找到 compspec 后，它用于生成 匹配的单词。 如果未找到 compspec，则默认 Bash 完成 ）。

First, the actions specified by the compspec are used. Only matches which are prefixed by the word being completed are returned. When the \-f or \-d option is used for filename or directory name completion, the shell variable `FIGNORE` is used to filter the matches. See [Bash Variables](https://www.gnu.org/software/bash/manual/bash.html#Bash-Variables), for a description of `FIGNORE`. 当 \-f 或 \-d目录名称补全，shell 变量 `FIGNORE`有关 `FIGNORE` 的说明，请参阅 [Bash 变量](https://www.gnu.org/software/bash/manual/bash.html#Bash-Variables)首先，使用 compspec 指定的操作。 只有以正在完成的单词为前缀的匹配项 返回。 选项用于文件名或 为 用于过滤匹配项。 。

Any completions specified by a filename expansion pattern to the \-G option are generated next. The words generated by the pattern need not match the word being completed. The `GLOBIGNORE` shell variable is not used to filter the matches, but the `FIGNORE` shell variable is used. 接下来生成 \-G`GLOBIGNORE`但使用了 `FIGNORE`文件名扩展模式指定的任何完成 选项。 模式生成的单词不必与正在完成的单词匹配。 shell 变量不用于筛选匹配项， shell 变量。

Next, the string specified as the argument to the \-W option is considered. The string is first split using the characters in the `IFS` special variable as delimiters. Shell quoting is honored within the string, in order to provide a mechanism for the words to contain shell metacharacters or characters in the value of `IFS`. Each word is then expanded using brace expansion, tilde expansion, parameter and variable expansion, command substitution, and arithmetic expansion, as described above (see [Shell Expansions](https://www.gnu.org/software/bash/manual/bash.html#Shell-Expansions)). The results are split using the rules described above (see [Word Splitting](https://www.gnu.org/software/bash/manual/bash.html#Word-Splitting)). The results of the expansion are prefix-matched against the word being completed, and the matching words become the possible completions. 接下来，指定为 \-W首先使用 `IFS``IFS`如上所述（请参阅 [Shell 扩展](https://www.gnu.org/software/bash/manual/bash.html#Shell-Expansions)（请参阅[拆分单词](https://www.gnu.org/software/bash/manual/bash.html#Word-Splitting) 选项参数的字符串 被考虑。 中的字符拆分字符串 特殊变量作为分隔符。 字符串中支持 Shell 引号，以便提供 单词包含 shell 元字符或字符的机制 的值中。 然后使用 大括号展开、波浪展开、参数和变量展开， 命令替换和算术扩展， ）。 使用上述规则拆分结果 ）。 扩展的结果与单词 being 的前缀匹配 完成，匹配的单词成为可能的完成。

After these matches have been generated, any shell function or command specified with the \-F and \-C options is invoked. When the command or function is invoked, the `COMP_LINE`, `COMP_POINT`, `COMP_KEY`, and `COMP_TYPE` variables are assigned values as described above (see [Bash Variables](https://www.gnu.org/software/bash/manual/bash.html#Bash-Variables)). If a shell function is being invoked, the `COMP_WORDS` and `COMP_CWORD` variables are also set. When the function or command is invoked, the first argument ($1) is the name of the command whose arguments are being completed, the second argument ($2) is the word being completed, and the third argument ($3) is the word preceding the word being completed on the current command line. No filtering of the generated completions against the word being completed is performed; the function or command has complete freedom in generating the matches. 调用使用 \-F 和 \-C调用命令或函数时，`COMP_LINE``COMP_POINT`、`COMP_KEY` 和 `COMP_TYPE`如上所述的赋值（请参阅 [Bash 变量](https://www.gnu.org/software/bash/manual/bash.html#Bash-Variables)如果正在调用 shell 函数，`COMP_WORDS``COMP_CWORD`生成这些匹配项后，任何 shell 函数或命令 选项指定的选项。 、 变量是 ）。 和 变量。 调用函数或命令时，第一个参数 （$1） 是 正在完成其参数的命令的名称， 第二个参数 （$2） 是正在完成的单词，第三个参数 （$3） 是当前命令上要完成的单词前面的单词 线。 不根据正在完成的单词过滤生成的补全 执行;函数或命令在生成时具有完全的自由 比赛。

Any function specified with \-F is invoked first. The function may use any of the shell facilities, including the `compgen` and `compopt` builtins described below (see [Programmable Completion Builtins](https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion-Builtins)), to generate the matches. It must put the possible completions in the `COMPREPLY` array variable, one per array element. 首先调用使用 \-F`compgen` 和 `compopt`（请参阅 [Programmable Completion Builtins](https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion-Builtins)它必须将可能的完成放在 `COMPREPLY` 指定的任何函数。 该函数可以使用任何 shell 工具，包括 内置函数如下所述 ），以生成匹配项。 数组中 变量，每个数组元素一个。

Next, any command specified with the \-C option is invoked in an environment equivalent to command substitution. It should print a list of completions, one per line, to the standard output. Backslash may be used to escape a newline, if necessary. 接下来，调用使用 \-C 选项指定的任何命令 在等同于命令替换的环境中。 它应该打印一个完成列表，每行一个，到 标准输出。 如有必要，可以使用反斜杠来转义换行符。

After all of the possible completions are generated, any filter specified with the \-X option is applied to the list. The filter is a pattern as used for pathname expansion; a ‘&’ in the pattern is replaced with the text of the word being completed. A literal ‘&’ may be escaped with a backslash; the backslash is removed before attempting a match. Any completion that matches the pattern will be removed from the list. A leading ‘!’ negates the pattern; in this case any completion not matching the pattern will be removed. If the `nocasematch` shell option (see the description of `shopt` in [The Shopt Builtin](https://www.gnu.org/software/bash/manual/bash.html#The-Shopt-Builtin)) is enabled, the match is performed without regard to the case of alphabetic characters. 使用 \-X筛选器是用于路径名扩展的模式;一个 '&文字“&前导的“!如果 `nocasematch`（参见 [The Shopt Builtin](https://www.gnu.org/software/bash/manual/bash.html#The-Shopt-Builtin) 中`shopt`生成所有可能的补全后，任何筛选器 选项指定的选项将应用于列表。 ' 在模式中替换为正在完成的单词的文本。 ”可以用反斜杠转义;反斜杠 在尝试匹配之前被删除。 任何与模式匹配的补全都将从列表中删除。 否定了模式;在这种情况下，任何完成 与图案不匹配的图案将被删除。 shell 选项 的描述） 启用，则在不考虑情况的情况下执行匹配 的字母字符。

Finally, any prefix and suffix specified with the \-P and \-S options are added to each member of the completion list, and the result is returned to the Readline completion code as the list of possible completions. 最后，使用 \-P 和 \-S 指定的任何前缀和后缀 选项将添加到完成列表的每个成员中，结果为 返回到 Readline 完成代码作为可能的列表 完成。

If the previously-applied actions do not generate any matches, and the \-o dirnames option was supplied to `complete` when the compspec was defined, directory name completion is attempted. \-o dirnames `complete`如果先前应用的操作未生成任何匹配项，并且 定义了 compspec，并尝试完成目录名称。

If the \-o plusdirs option was supplied to `complete` when the compspec was defined, directory name completion is attempted and any matches are added to the results of the other actions. 如果提供了 \-o plusdirs 选项以在以下情况下`complete` 定义了 compspec，尝试完成目录名称，并且任何 匹配项将添加到其他操作的结果中。

By default, if a compspec is found, whatever it generates is returned to the completion code as the full set of possible completions. The default Bash completions are not attempted, and the Readline default of filename completion is disabled. If the \-o bashdefault option was supplied to `complete` when the compspec was defined, the default Bash completions are attempted if the compspec generates no matches. If the \-o default option was supplied to `complete` when the compspec was defined, Readline’s default completion will be performed if the compspec (and, if attempted, the default Bash completions) generate no matches. 如果提供了 \-o bashdefault 选项以`complete`如果提供了 \-o default选项以`complete`默认情况下，如果找到 compspec，则它生成的任何内容都会返回到 完成代码作为可能完成的完整集合。 不尝试默认的 Bash 完成，并且 Readline 默认 的文件名补全被禁用。 以下情况 定义了 compspec，尝试默认的 Bash 完成 如果 CompSpec 未生成匹配项。 当 compspec 已定义，将执行 Readline 的默认完成 如果 compspec（如果尝试，则默认 Bash 完成） 不生成匹配项。

When a compspec indicates that directory name completion is desired, the programmable completion functions force Readline to append a slash to completed names which are symbolic links to directories, subject to the value of the mark-directories Readline variable, regardless of the setting of the mark-symlinked-directories Readline variable. mark-directoriesmark-symlinked-directories当 compspec 指示需要目录名称补全时， 可编程补全函数强制 Readline 附加斜杠 到已完成的目录，这些名称是指向目录的符号链接，但须遵守 Readline 变量的值，无论 Readline 变量的设置。

There is some support for dynamically modifying completions. This is most useful when used in combination with a default completion specified with \-D. It’s possible for shell functions executed as completion handlers to indicate that completion should be retried by returning an exit status of 124. If a shell function returns 124, and changes the compspec associated with the command on which completion is being attempted (supplied as the first argument when the function is executed), programmable completion restarts from the beginning, with an attempt to find a new compspec for that command. This allows a set of completions to be built dynamically as completion is attempted, rather than being loaded all at once. 使用 \-D有一些对动态修改补全的支持。 这是 与指定的默认补全结合使用时最有用 。 shell 函数可以作为完成执行 处理程序，指示应通过返回 退出状态为 124。 如果 shell 函数返回 124，并更改 与正在完成的命令关联的 CompSpec attempt（在执行函数时作为第一个参数提供）， 可编程完成从头开始重新启动，并带有 尝试为该命令查找新的 compspec。 这允许一组 在尝试完成时动态构建完成，而不是 一次加载完毕。

For instance, assuming that there is a library of compspecs, each kept in a file corresponding to the name of the command, the following default completion function would load completions dynamically: 例如，假设有一个 compspec 库，每个 compspec 都保存在 文件对应的命令名称，以下默认 完成函数将动态加载完成：

```
_completion_loader()
{
    . "/etc/bash_completion.d/$1.sh" &gt;/dev/null 2&gt;&amp;1 &amp;&amp; return 124
}
complete -D -F _completion_loader -o bashdefault -o default
```

___

### 8.7 Programmable Completion Builtins8.7 内置可编程补全

Three builtin commands are available to manipulate the programmable completion facilities: one to specify how the arguments to a particular command are to be completed, and two to modify the completion as it is happening. 有三个内置命令可用于操作可编程完成 设施：一个用于指定特定命令的参数如何 完成，两个在完成时修改完成。

`compgen`

Generate possible completion matches for word according to the options, which may be any option accepted by the `complete` builtin with the exception of \-p and \-r, and write the matches to the standard output. When using the \-F or \-C options, the various shell variables set by the programmable completion facilities, while available, will not have useful values. wordoption`complete`内置，除了 \-p 和 \-r使用 \-F 或 \-C S，它可以是 ，并写入 与标准输出匹配。 选项时，各种 shell 变量 由可编程完成设施设置，虽然可用，但不会 具有有用的值。

The matches will be generated in the same way as if the programmable completion code had generated them directly from a completion specification with the same flags. If word is specified, only those completions matching word will be displayed. 如果指定word，则只有那些与word匹配项的生成方式与可编程项相同 完成代码是直接从完成规范生成的 使用相同的标志。 匹配的补全 将显示。

The return value is true unless an invalid option is supplied, or no matches were generated. 返回值为 true，除非提供了无效选项，否则返回值为 true 或 no 生成匹配项。

`complete`

```
complete [-abcdefgjksuv] [-o comp-option] [-DEI] [-A action] [-G globpat]
[-W wordlist] [-F function] [-C command] [-X filterpat]
[-P prefix] [-S suffix] name [name …]
```

Specify how arguments to each name should be completed. If the \-p option is supplied, or if no options are supplied, existing completion specifications are printed in a way that allows them to be reused as input. The \-r option removes a completion specification for each name, or, if no names are supplied, all completion specifications. The \-D option indicates that other supplied options and actions should apply to the “default” command completion; that is, completion attempted on a command for which no completion has previously been defined. The \-E option indicates that other supplied options and actions should apply to “empty” command completion; that is, completion attempted on a blank line. The \-I option indicates that other supplied options and actions should apply to completion on the initial non-assignment word on the line, or after a command delimiter such as ‘;’ or ‘|’, which is usually command name completion. If multiple options are supplied, the \-D option takes precedence over \-E, and both take precedence over \-I. If any of \-D, \-E, or \-I are supplied, any other name arguments are ignored; these completions only apply to the case specified by the option. 指定每个name如果提供了 \-p\-r每个name，或者，如果未提供name\-D\-E\-I命令分隔符，例如“;”或“|如果提供了多个选项，\-D超过 \-E，并且两者都优先\-I如果提供了 \-D、\-E 或 \-Iname的参数应如何完成。 选项，或者未提供任何选项，则现有 完成规范的打印方式允许它们 重用为输入。 选项删除了 s，则全部 完成规范。 选项指示提供的其他选项和操作应 应用于“默认”命令完成;也就是说，尝试完成 在以前未定义完成的命令上。 选项指示提供的其他选项和操作应 适用于“空”命令完成;也就是说，尝试完成 空行。 选项指示提供的其他选项和操作应 应用于完成该行的初始非赋值词，或在 ”，通常是命令 名称补全。 选项优先 。 中的任何一个，则任何其他 参数将被忽略;这些完成仅适用于案例 由选项指定。

The process of applying these completion specifications when word completion is attempted is described above (see [Programmable Completion](https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion)). 尝试如上所述（请参阅[可编程完成](https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion)单词完成时应用这些完成规范的过程 ）。

Other options, if specified, have the following meanings. The arguments to the \-G, \-W, and \-X options (and, if necessary, the \-P and \-S options) should be quoted to protect them from expansion before the `complete` builtin is invoked. \-G、\-W 和 \-X（如有必要，还有 \-P 和 \-S`complete`其他选项（如果指定）具有以下含义。 选项的参数 选项） 应引用以保护它们在 builtin。

`-o comp-option`\-或 comp-option

The comp-option controls several aspects of the compspec’s behavior beyond the simple generation of completions. comp-option may be one of: comp-optioncomp-option 控制 compspec 行为的几个方面 超越简单的完成生成。 可以是以下选项之一：

`bashdefault`

Perform the rest of the default Bash completions if the compspec generates no matches. 如果 compspec 不生成任何匹配项。

`default`

Use Readline’s default filename completion if the compspec generates no matches. 如果 compspec 生成，请使用 Readline 的默认文件名补全 没有匹配项。

`dirnames`

Perform directory name completion if the compspec generates no matches. 如果 compspec 未生成匹配项，则执行目录名称补全。

`filenames`

Tell Readline that the compspec generates filenames, so it can perform any filename-specific processing (like adding a slash to directory names, quoting special characters, or suppressing trailing spaces). This option is intended to be used with shell functions specified with \-F. 使用 \-F告诉 Readline compspec 生成文件名，因此它可以执行任何 特定于文件名的处理（例如在目录名称中添加斜杠， 引用特殊字符，或禁止尾随空格）。 此选项旨在与指定的 shell 函数一起使用 。

`noquote`

Tell Readline not to quote the completed words if they are filenames (quoting filenames is the default). 告诉 Readline 不要引用已完成的单词（如果它们是文件名） （引用文件名是默认值）。

`nosort`

Tell Readline not to sort the list of possible completions alphabetically. 告诉 Readline 不要按字母顺序对可能的完成列表进行排序。

`nospace`

Tell Readline not to append a space (the default) to words completed at the end of the line. 告诉 Readline 不要在完成的单词上附加空格（默认值） 行的末尾。

`plusdirs`

After any matches defined by the compspec are generated, directory name completion is attempted and any matches are added to the results of the other actions. 生成 compspec 定义的任何匹配项后， 尝试完成目录名称，并且任何 匹配项将添加到其他操作的结果中。

`-A action`\-action

The action may be one of the following to generate a list of possible completions: action可以是以下操作之一，以生成可能的列表 完成：

`alias`

Alias names. May also be specified as \-a. 别名。 也可以指定为 \-a。

`arrayvar`

Array variable names. 数组变量名称。

`binding`

Readline key binding names (see [Bindable Readline Commands](https://www.gnu.org/software/bash/manual/bash.html#Bindable-Readline-Commands)). Readline 键绑定名称（请参阅[可绑定的 Readline 命令](https://www.gnu.org/software/bash/manual/bash.html#Bindable-Readline-Commands)）。

`builtin`

Names of shell builtin commands. May also be specified as \-b. shell 内置命令的名称。 也可以指定为 \-b。

`command`

Command names. May also be specified as \-c. 命令名称。 也可以指定为 \-c。

`directory`

Directory names. May also be specified as \-d. 目录名称。 也可以指定为 \-d。

`disabled`

Names of disabled shell builtins. 禁用的 shell 内置函数的名称。

`enabled`

Names of enabled shell builtins. 已启用的 shell 内置项的名称。

`export`

Names of exported shell variables. May also be specified as \-e. 导出的 shell 变量的名称。 也可以指定为 \-e。

`file`

File names. May also be specified as \-f. 文件名。 也可以指定为 \-f。

`function`

Names of shell functions. shell 函数的名称。

`group`

Group names. May also be specified as \-g. 组名称。 也可以指定为 \-g。

`helptopic`

Help topics as accepted by the `help` builtin (see [Bash Builtin Commands](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins)). `help`接受的帮助主题（请参阅 [Bash 内置命令](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins)）。

`hostname`

Hostnames, as taken from the file specified by the `HOSTFILE` shell variable (see [Bash Variables](https://www.gnu.org/software/bash/manual/bash.html#Bash-Variables)). `HOSTFILE` shell 变量（请参阅 [Bash 变量](https://www.gnu.org/software/bash/manual/bash.html#Bash-Variables)主机名，取自 ）。

`job`

Job names, if job control is active. May also be specified as \-j. 作业名称（如果作业控制处于活动状态）。 也可以指定为 \-j。

`keyword`

Shell reserved words. May also be specified as \-k. 壳牌保留字。 也可以指定为 \-k。

`running`

Names of running jobs, if job control is active. 如果作业控制处于活动状态，则正在运行的作业的名称。

`service`

Service names. May also be specified as \-s. 服务名称。 也可以指定为 \-s。

`setopt`

Valid arguments for the \-o option to the `set` builtin (see [The Set Builtin](https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin)). `set`内置的 \-o（请参阅[内置设置](https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin) 选项的有效参数 ）。

`shopt`

Shell option names as accepted by the `shopt` builtin (see [Bash Builtin Commands](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins)). `shopt`（请参阅 [Bash 内置命令](https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins) 内置接受的 shell 选项名称 ）。

`signal`

Signal names. 信号名称。

`stopped`

Names of stopped jobs, if job control is active. 如果作业控制处于活动状态，则已停止作业的名称。

`user`

User names. May also be specified as \-u. 用户名。 也可以指定为 \-u。

`variable`

Names of all shell variables. May also be specified as \-v. 所有 shell 变量的名称。 也可以指定为 \-v。

`-C command`\-C command

command is executed in a subshell environment, and its output is used as the possible completions. Arguments are passed as with the \-F option. command参数与 \-F在子 shell 环境中执行，其输出为 用作可能的完成。 选项一样传递。

`-F function`\-F function

The shell function function is executed in the current shell environment. When it is executed, $1 is the name of the command whose arguments are being completed, $2 is the word being completed, and $3 is the word preceding the word being completed, as described above (see [Programmable Completion](https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion)). When it finishes, the possible completions are retrieved from the value of the `COMPREPLY` array variable. shell 函数function（请参阅[可编程完成](https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion)`COMPREPLY`在当前 shell 中执行 环境。 执行时，$1 是参数为 完成，$2 是正在完成的单词，$3 是单词 如上所述，在单词完成之前 ）。 完成后，将从值中检索可能的完成 数组变量。

`-G globpat`\-Gglobpat

The filename expansion pattern globpat is expanded to generate the possible completions. 文件名扩展模式 globpat 展开以生成 可能的完成。

`-P prefix`\-P prefix

prefix is added at the beginning of each possible completion after all other options have been applied. prefix在每个可能的完成开始时添加 在应用了所有其他选项之后。

`-S suffix`\-S suffix

suffix is appended to each possible completion after all other options have been applied. 后suffix附加到每个可能的完成 在应用了所有其他选项之后。

`-W wordlist`\-wordlist

The wordlist is split using the characters in the `IFS` special variable as delimiters, and each resultant word is expanded. The possible completions are the members of the resultant list which match the word being completed. wordlist`IFS`使用 特殊变量作为分隔符，以及每个合成词 展开。 可能的完成是结果列表的成员，这些成员 匹配正在完成的单词。

`-X filterpat`\-X filterpat

filterpat is a pattern as used for filename expansion. It is applied to the list of possible completions generated by the preceding options and arguments, and each completion matching filterpat is removed from the list. A leading ‘!’ in filterpat negates the pattern; in this case, any completion not matching filterpat is removed. filterpatfilterpatfilterpat 中的前导“!情况下，将删除任何与 filterpat 是一种用于文件名扩展的模式。 它适用于由 前面的选项和参数，以及每个补全匹配项 将从列表中删除。 否定了该模式;在这个 不匹配的补全。

The return value is true unless an invalid option is supplied, an option other than \-p or \-r is supplied without a name argument, an attempt is made to remove a completion specification for a name for which no specification exists, or an error occurs adding a completion specification. 除了 \-p 或 \-r 之外，没有name不存在规范name返回值为 true，除非提供了无效的选项，即选项 参数，则尝试删除 ，或 添加完成规范时出错。

`compopt`

```
compopt
```

Modify completion options for each name according to the options, or for the currently-executing completion if no names are supplied. If no options are given, display the completion options for each name or the current completion. The possible values of option are those valid for the `complete` builtin described above. The \-D option indicates that other supplied options should apply to the “default” command completion; that is, completion attempted on a command for which no completion has previously been defined. The \-E option indicates that other supplied options should apply to “empty” command completion; that is, completion attempted on a blank line. The \-I option indicates that other supplied options should apply to completion on the initial non-assignment word on the line, or after a command delimiter such as ‘;’ or ‘|’, which is usually command name completion. nameoptions，或者如果没有name如果未给出optionnameoption 的可能值是那些对 `complete`\-D\-E\-I命令分隔符，例如“;”或“| s 时用于当前正在执行的完成 提供。 ，则显示每个选项的完成选项 或当前完成。 有效的值 内置，如上所述。 选项指示提供的其他选项应 应用于“默认”命令完成;也就是说，尝试完成 在以前未定义完成的命令上。 选项指示提供的其他选项应 适用于“空”命令完成;也就是说，尝试完成 空行。 选项指示提供的其他选项应 应用于完成该行的初始非赋值词，或在 ”，通常是命令 名称补全。

If multiple options are supplied, the \-D option takes precedence over \-E, and both take precedence over \-I如果提供了多个选项，\-D超过 \-E，并且两者都优先\-I 选项优先

The return value is true unless an invalid option is supplied, an attempt is made to modify the options for a name for which no completion specification exists, or an output error occurs. 用于修改未完成的name返回值为 true，除非提供了无效选项，否则尝试 的选项 存在规范，或发生输出错误。

___

### 8.8 A Programmable Completion Example8.8 A 可编程完成示例

The most common way to obtain additional completion functionality beyond the default actions `complete` and `compgen` provide is to use a shell function and bind it to a particular command using `complete -F`. 默认操作 `complete` 和 `compgen`一个 shell 函数，并使用 `complete -F`获得其他完成功能的最常见方法 提供的是使用 将其绑定到特定命令。

The following function provides completions for the `cd` builtin. It is a reasonably good example of what shell functions must do when used for completion. This function uses the word passed as `$2` to determine the directory name to complete. You can also use the `COMP_WORDS` array variable; the current word is indexed by the `COMP_CWORD` variable. 以下函数提供内置 `cd`用于完成。 此函数使用传递为 `$2``COMP_WORDS``COMP_CWORD` 的补全。 这是一个相当好的例子，说明shell函数在以下情况下必须做什么 的单词 确定要完成的目录名称。 您还可以使用 数组变量;当前单词由 变量。

The function relies on the `complete` and `compgen` builtins to do much of the work, adding only the things that the Bash `cd` does beyond accepting basic directory names: tilde expansion (see [Tilde Expansion](https://www.gnu.org/software/bash/manual/bash.html#Tilde-Expansion)), searching directories in $CDPATH, which is described above (see [Bourne Shell Builtins](https://www.gnu.org/software/bash/manual/bash.html#Bourne-Shell-Builtins)), and basic support for the `cdable_vars` shell option (see [The Shopt Builtin](https://www.gnu.org/software/bash/manual/bash.html#The-Shopt-Builtin)). `_comp_cd` modifies the value of IFS so that it contains only a newline to accommodate file names containing spaces and tabs – `compgen` prints the possible completions it generates one per line. 该函数依赖于 `complete` 和 `compgen`做大部分工作，只添加 Bash `cd`波浪号展开（参见[波浪号展开](https://www.gnu.org/software/bash/manual/bash.html#Tilde-Expansion)在$CDPATH（参见 [Bourne Shell Builtins](https://www.gnu.org/software/bash/manual/bash.html#Bourne-Shell-Builtins)以及对 `cdable_vars`（参见 [The Shopt Builtin](https://www.gnu.org/software/bash/manual/bash.html#The-Shopt-Builtin)`_comp_cd`修改 IFS`compgen` 内置函数 的东西 除了接受基本目录名称之外： ）， 中搜索目录，如上所述 ）， shell 选项的基本支持 ）。 的值，使其仅包含 用于容纳包含空格和制表符的文件名的换行符 – 每行打印一个可能生成的完成。

Possible completions go into the COMPREPLY array variable, one completion per array element. The programmable completion system retrieves the completions from there when the function returns. 可能的完成进入 COMPREPLY 数组变量 1 每个数组元素的完成。 可编程完成系统检索 函数返回时从那里完成的。

```
# A completion function for the cd builtin
# based on the cd completion function from the bash_completion package
_comp_cd()
{
    local IFS=$' \t\n'    # normalize IFS
    local cur _skipdot _cdpath
    local i j k

    # Tilde expansion, which also expands tilde to full pathname
    case "$2" in
    \~*)    eval cur="$2" ;;
    *)      cur=$2 ;;
    esac

    # no cdpath or absolute pathname -- straight directory completion
    if [[ -z "${CDPATH:-}" ]] || [[ "$cur" == @(./*|../*|/*) ]]; then
        # compgen prints paths one per line; could also use while loop
        IFS=$'\n'
        COMPREPLY=( $(compgen -d -- "$cur") )
        IFS=$' \t\n'
    # CDPATH+directories in the current directory if not in CDPATH
    else
        IFS=$'\n'
        _skipdot=false
        # preprocess CDPATH to convert null directory names to .
        _cdpath=${CDPATH/#:/.:}
        _cdpath=${_cdpath//::/:.:}
        _cdpath=${_cdpath/%:/:.}
        for i in ${_cdpath//:/$'\n'}; do
            if [[ $i -ef . ]]; then _skipdot=true; fi
            k="${#COMPREPLY[@]}"
            for j in $( compgen -d -- "$i/$cur" ); do
                COMPREPLY[k++]=${j#$i/}        # cut off directory
            done
        done
        $_skipdot || COMPREPLY+=( $(compgen -d -- "$cur") )
        IFS=$' \t\n'
    fi

    # variable names if appropriate shell option set and no completions
    if shopt -q cdable_vars &amp;&amp; [[ ${#COMPREPLY[@]} -eq 0 ]]; then
        COMPREPLY=( $(compgen -v -- "$cur") )
    fi

    return 0
}
```

We install the completion function using the \-F option to `complete`: 我们使用 \-F`complete` 选项安装完成函数 ：

```
# Tell readline to quote appropriate and append slashes to directories;
# use the bash default completion for other arguments
complete -o filenames -o nospace -o bashdefault -F _comp_cd cd
```

Since we’d like Bash and Readline to take care of some of the other details for us, we use several other options to tell Bash and Readline what to do. The \-o filenames option tells Readline that the possible completions should be treated as filenames, and quoted appropriately. That option will also cause Readline to append a slash to filenames it can determine are directories (which is why we might want to extend `_comp_cd` to append a slash if we’re using directories found via CDPATH: Readline can’t tell those completions are directories). The \-o nospace option tells Readline to not append a space character to the directory name, in case we want to append to it. The \-o bashdefault option brings in the rest of the "Bash default" completions – possible completions that Bash adds to the default Readline set. These include things like command name completion, variable completion for words beginning with ‘$’ or ‘${’, completions containing pathname expansion patterns (see [Filename Expansion](https://www.gnu.org/software/bash/manual/bash.html#Filename-Expansion)), and so on. 和 Readline 该怎么做。 \-o filenames如果我们使用的是找到的目录，请扩展`_comp_cd`通过 CDPATH\-o nospace\-o bashdefault对于以“$”或“${扩展模式（请参阅[文件名扩展](https://www.gnu.org/software/bash/manual/bash.html#Filename-Expansion)因为我们希望 Bash 和 Readline 能够处理一些问题 对于我们的其他细节，我们使用其他几个选项来告诉 Bash 选项告诉 Readline 可能的完成应被视为文件名，并引用 适当地。 该选项还会导致 Readline 将斜杠附加到 它可以确定的文件名是目录（这就是为什么我们可能想要 以附加斜杠 Readline 无法判断这些完成是目录）。 选项告诉 Readline 不要附加空格 字符添加到目录名称中，以防我们想附加到它。 选项引入了“Bash 默认值”的其余部分 completedions – Bash 添加到默认 Readline 的可能完成 设置。 其中包括命令名称完成、变量完成等内容 ”开头的单词，包含路径名的补全 ）等。

Once installed using `complete`, `_comp_cd` will be called every time we attempt word completion for a `cd` command. 使用 `complete` 安装后，`_comp_cd`我们尝试 `cd`将调用 命令的单词补全时间。

Many more examples – an extensive collection of completions for most of the common GNU, Unix, and Linux commands – are available as part of the bash\_completion project. This is installed by default on many GNU/Linux distributions. Originally written by Ian Macdonald, the project now lives at [https://github.com/scop/bash-completion/](https://github.com/scop/bash-completion/). There are ports for other systems such as Solaris and Mac OS X. 在 [https://github.com/scop/bash-completion/](https://github.com/scop/bash-completion/)还有更多例子 - 大多数 常见的 GNU、Unix 和 Linux 命令 – 作为 bash\_completion项目。 默认情况下，它安装在许多 GNU/Linux 上 分布。 该项目最初由伊恩·麦克唐纳（Ian Macdonald）撰写，现已生效 。 有端口用于 其他系统，如 Solaris 和 Mac OS X。

An older version of the bash\_completion package is distributed with bash in the examples/complete subdirectory. examples/complete旧版本的 bash\_completion 包随 bash 一起分发 子目录中。
