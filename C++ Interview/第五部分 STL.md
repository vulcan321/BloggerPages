第五部分、 STL
1、STL 六大组件
STL 六大组件：容器（Container）、算法（Algorithm）、迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）和 空间配置器（allocator）。

2、stack 中有 pop() 和 top() 方法，为什么不直接用 pop() 实现弹出和取值的功能？
把pop()和top()的功能放在一个函数中，如果 stack 中存放的是较大是内容时，比如 vector 类型，取值的时候就会发生拷贝，如果拷贝失败，要弹出的数据将会丢失；就很可能出现下述的bug，导致原始数据丢失。
假设有一个stack，vector是一个动态容器，当你拷贝一个vector时，标准库会从堆上分配很多内存来完成这次拷贝。当这个系统处在重度负荷，或有严重的资源限制的情况下，这种内存分配就会失败，所以vector的拷贝构造函数可能会抛出一个std::bad_alloc异常。当vector中存有大量元素时，这种情况发生的可能性更大。当pop()函数返回“弹出值”时(也就是从栈中将这个值移除)，会有一个潜在的问题：这个值被返回到调用函数的时候，栈才被改变；但当拷贝数据的时候，调用函数抛出一个异常会怎么样？如果事情真的发生了，要弹出的数据将会丢失；它的确从栈上移出了，但是拷贝失败了！std::stack的设计人员将这个操作分为两个部分：先获取顶部元素(top())，然后从栈中移除元素(pop())。这样，在不能安全的将元素拷贝出去的情况下，栈中的这个数据还依旧存在，没有丢失。当问题是堆空间不足时，应用可能会释放一些内存，然后再进行尝试。
参考： 为什么适配器stack中成员函数top()和pop()需要分离实现

3、 STL库用过吗？常见的STL容器有哪些？算法用过几个？
STL包括两部分内容：容器和算法
容器即存放数据的地方，比如array, vector，分为两类，序列式容器和关联式容器
序列式容器，其中的元素不一定有序，但是都可以被排序，比如vector,list,queue,stack，heap, priority-queue, slist
关联式容器，内部结构是一个平衡二叉树，每个元素都有一个键值和一个实值，比如map, set, hashtable, hash_set
算法有排序，复制等，以及各个容器特定的算法
迭代器是STL的精髓，迭代器提供了一种方法，使得它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构，它将容器和算法分开，让二者独立设计。
Vector是顺序容器，是一个动态数组，支持随机存取、插入、删除、查找等操作，在内存中是一块连续的空间。在原有空间不够情况下自动分配空间，增加为原来的两倍。vector随机存取效率高，但是在vector插入元素，需要移动的数目多，效率低下。
注意：vector动态增加大小时，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。

4、STL中map 、set、multiset、multimap的底层原理（关联式容器）
map 、set 、multiset 、multimap 的底层实现都是红黑树。
红 黑 树 的 特 性 ：

每个结点或是红色或是黑色；
根结点是黑色；
每个叶结点是黑的；
如果一个结点是红的，则它的两个儿子均是黑色；
每个结点到其子孙结点的所有路径上包含相同数目的黑色结点。
5、map 、set、multiset、multimap的特点
set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。
map和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序（因为红黑树也是二叉搜索树，所以map默认是按key排序的），map中元素的key不允许重复，multimap可以重复。
map和set的增删改查速度为都是logn，是比较高效的。
6、hash_map与map的区别？什么时候用hash_map，什么时候用map？
构造函数：hash_map需要hash function和等于函数，而map需要比较函数（大于或小于）。
存储结构：hash_map以hashtable为底层，而map以RB-TREE为底层。
总的说来，hash_map查找速度比map快，而且查找速度基本和数据量大小无关，属于常数级别。而map的查找速度是logn级别。但不一定常数就比log小，而且hash_map还有hash function耗时。
如果考虑效率，特别当元素达到一定数量级时，用hash_map。
考虑内存，或者元素数量较少时，用map。

7、STL中unordered_map和map的区别
map是STL中的一个关联容器，提供键值对的数据管理。底层通过红黑树来实现，实际上是二叉排序树和非严格意义上的二叉平衡树。所以在map内部所有的数据都是有序的，且map的查询、插入、删除操作的时间复杂度都是O(logN)。
unordered_map和map类似，都是存储key-value对，可以通过key快速索引到value，不同的是unordered_map不会根据key进行排序。unordered_map底层是一个防冗余的哈希表，存储时根据key的hash值判断元素是否相同，即unoredered_map内部是无序的。

8、STL中的vector的实现，是怎么扩容的？
vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。
vector就是一个动态增长的数组，里面有一个指针指向一片连续的空间，当空间装不下的时候，会申请一片更大的空间，将原来的数据拷贝过去，并释放原来的旧空间。当删除的时候空间并不会被释放，只是清空了里面的数据。对比array是静态空间一旦配置了就不能改变大小。
vector的动态增加大小的时候，并不是在原有的空间上持续新的空间（无法保证原空间的后面还有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，并释放原空间。在VS下是1.5倍扩容，在GCC下是2倍扩容。

9、C++中vector和list的区别
vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。
vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+=”，“<”等操作符。
list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+=”、“<”等
vector::iterator和list::iterator都重载了“++”运算符。
总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;
如果需要大量的插入和删除，而不关心随机存取，则应使用list。

10、STL内存优化？
STL内存管理使用二级内存配置器。

第一级配置器：
第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。一级空间配置器分配的是大于128字节的空间，如果分配不成功，调用句柄释放一部分内存，如果还不能分配成功，抛出异常。
第一级配置器只是对malloc函数和free函数的简单封装，在allocate内调用malloc，在deallocate内调用free。同时第一级配置器的oom_malloc函数，用来处理malloc失败的情况。
第二级配置器：
第一级配置器直接调用malloc和free带来了几个问题：
内存分配/释放的效率低
当配置大量的小内存块时，会导致内存碎片比较严重
配置内存时，需要额外的部分空间存储内存块信息，所以配置大量的小内存块时，还会导致额外内存负担
如果分配的区块小于128bytes，则以内存池管理，第二级配置器维护了一个自由链表数组，每次需要分配内存时，直接从相应的链表上取出一个内存节点就完成工作，效率很高。
自由链表数组：自由链表数组其实就是个指针数组，数组中的每个指针元素指向一个链表的起始节点。数组大小为16，即维护了16个链表，链表的每个节点就是实际的内存块，相同链表上的内存块大小都相同，不同链表的内存块大小不同，从8一直到128。如下所示，obj为链表上的节点，free_list就是链表数组。
内存分配：allocate函数内先判断要分配的内存大小，若大于128字节，直接调用第一级配置器，否则根据要分配的内存大小从16个链表中选出一个链表，取出该链表的第一个节点。若相应的链表为空，则调用refill函数填充该链表。默认是取出20个数据块。
填充链表 refill：若allocate函数内要取出节点的链表为空，则会调用refill函数填充该链表。refill函数内会先调用chunk_alloc函数从内存池分配一大块内存，该内存大小默认为20个链表节点大小，当内存池的内存也不足时，返回的内存块节点数目会不足20个。接着refill的工作就是将这一大块内存分成20份相同大小的内存块，并将各内存块连接起来形成一个链表。
内存池：chunk_alloc函数内管理了一块内存池，当refill函数要填充链表时，就会调用chunk_alloc函数，从内存池取出相应的内存。
在chunk_alloc函数内首先判断内存池大小是否足够填充一个有20个节点的链表，若内存池足够大，则直接返回20个内存节点大小的内存块给refill；
若内存池大小无法满足20个内存节点的大小，但至少满足1个内存节点，则直接返回相应的内存节点大小的内存块给refill；
若内存池连1个内存节点大小的内存块都无法提供，则chunk_alloc函数会将内存池中那一点点的内存大小分配给其他合适的链表，然后去调用malloc函数分配的内存大小为所需的两倍。若malloc成功，则返回相应的内存大小给refill；若malloc失败，会先搜寻其他链表的可用的内存块，添加到内存池，然后递归调用chunk_alloc函数来分配内存，若其他链表也无内存块可用，则只能调用第一级空间配置器。
11、正确释放vector的内存(clear(), swap(), shrink_to_fit())
vec.clear()：清空内容，但是不释放内存。
vector().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。
vec.shrink_to_fit()：请求容器降低其capacity和size匹配。
vec.clear();vec.shrink_to_fit();：清空内容，且释放内存。

12、什么情况下用vector，什么情况下用list，什么情况下用deque
vector可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，随机访问频繁。除非必要，我们尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。
list不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。
需要从首尾两端进行插入或删除操作的时候需要选择deque。
13、priority_queue的底层原理
priority_queue：优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个

14、 STL线程不安全的情况
在对同一个容器进行多线程的读写、写操作时；
在每次调用容器的成员函数期间都要锁定该容器；
在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器；
在每个在容器上调用的算法执行期间锁定该容器。
推荐阅读： C++ STL容器如何解决线程安全的问题？

15、vector 中迭代器失效的情况
当插入（push_back）一个元素后，end操作返回的迭代器肯定失效。
当插入(push_back)一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时first和end操作返回的迭代器都会失效。
当进行删除操作（erase，pop_back）后，指向删除点的迭代器全部失效；指向删除点后面的元素的迭代器也将全部失效。
16、迭代器的几种失效的情况
vector、deque，该数据结构分配在连续的内存中，当删除一个元素后，内存中的数据会发生移动以保证数据的紧凑。所以删除一个元素后，其他数据的地址发生了变化，之前获取的迭代器根据原有信息就访问不到正确的数据
解决方法：erase返回下一个有效迭代器的值
map、set、multiset、map、multimap，树形数据结构。以红黑树或者平衡二叉树组织数据，虽然删除了一个元素，整棵树也会调整，以符合红黑树或者二叉树的规范，但是单个节点在内存中的地址没有变化，变化的是各节点之间的指向关系。删除一个结点不会对其他结点造成影响。
erase迭代器只是被删元素的迭代器失效。
list，链表型数据结构。双向链表，使用不连续分配的内存，删除运算使指向删除位置的迭代器失效，不会使其他迭代器失效。
17、STL 是复制性还是侵入性
STL实现的容器都是非侵入式容器，通过模板类可以放入任何类型的结构，与浸入式容器的最大不同是，C++的非侵入式容器必须存储用户数据的拷贝
参考： STL容器概述

18、vector使用注意事项
在push_back()、resize()、insert()后有可能引起重新分配内存，此时原始的迭代器失效，需要重新生成一次迭代器
为了防止多次扩容造成性能低，可以先使用reserve()，预留足够的空间，最后在使用 shrink_to_fit()收缩空间
vector不能用来存储bool类型的元素，存储机理不同，bool类型的元素存储到vector中，会转化为1个bit，不是1个byte，可以用deque或者是bitset存储bool类型的
vector的扩容：VS是1.5倍、GCC是2倍