# 2、Qt 的核心机制

## 元对象系统 

Qt的元对象系统（meta-object）提供了用于内部对象通讯的信号与槽（signals & slots）机制，运行时类型信息，以及动态属性系统（dynamic property system）。 整个元对象系统基于三个东西建立：

QObject类为所有对象提供了一个基类，只要继承此类，那创建出的对象便可以使用元对象系统。
在声明类时，将Q_OBJECT宏放置于类的私有区域就可以在类中使能元对象特性，诸如动态属性，信号，以及槽。一般实际使用中，我们总是把Q_OBJECT宏放置在类声明时的开头位置，除此之外我们的类还需要继承QObject类。

元对象编译器（Meta-Object Compiler，缩写moc），为每个QObject的子类提供必要的代码去实现元对象特性。我们可以认为Qt对C++进行了一些拓展，moc则是负责将这些拓展语法翻译成原生的C++语法，之后交给C++编译器去编译。

moc工具读取c++源文件。如果它找到一个或多个包含Q_OBJECT宏的类声明，它会生成另一个c++源文件，其中包含每个类的元对象代码。生成的源文件要么`#include`到类的源文件中，要么(更常见的情况)编译并链接到类的实现。

## 属性系统 

如同很多编译器厂商提供的编译器一样，Qt也提供了一个精妙的属性系统。然而，作为一个独立于编译器和架构的库，Qt不依赖于诸如__property或[property]这样的非标准的编译器特性。Qt的这套属性系统特性可以用于任何Qt支持的编译器与架构。它基于元对象系统（Meta-Object System），这套系统同时也提供信号与槽机制用于对象间通讯。 

以下摘录简要说明了属性与成员变量的区别：

成员变量是一个“内”概念，反映的是类的结构构成。属性是一个“外”概念，反映的是类的逻辑意义。
成员变量没有读写权限控制，而属性可以指定为只读或只写，或可读可写。
成员变量不对读出作任何后处理，不对写入作任何预处理，而属性则可以。
public成员变量可以视为一个可读可写、没有任何预处理或后处理的属性。 而private成员变量由于外部不可见，与属性“外”的特性不相符，所以不能视为属性。

虽然大多数情况下，属性会由某个或某些成员变量来表示，但属性与成员变量没有必然的对应关系， 比如与非门的 output 属性，就没有一个所谓的 $output 成员变量与之对应。 属性 与成员变量的 区别与联系 及属性修饰词理解

## 信号与槽 

信号与槽用于对象之间的通讯。

在Qt中，使用了信号与槽机制代替了回调机制。信号将会在特定的事件出现时被发出。Qt的控件预定义了很多信号，当然我们也可以继承这些控件以定义自己的子类，然后添加自己的信号。槽是在响应特定信号时会被调用的方法。Qt的控件存在很多预定义的槽，但通常的做法是继承控件以生成自己的子类，然后添加自己的槽，这样我们就可以自行处理感兴趣的信号。

详见： QT核心机制：元系统 属性系统 信号与槽

# 3、信号与槽机制 原理 具体流程

moc查找头文件中的signals，slots，标记出信号和槽。
将信号槽信息存储到类静态变量staticMetaObject中，并且按声明顺序进行存放，建立索引。
当发现有connect连接时，将信号槽的索引信息放到一个map中，彼此配对。
当调用emit时，调用信号函数，并且传递发送信号的对象指针，元对象指针，信号索引，参数列表到active函数；
通过active函数找到在map中找到所有与信号对应的槽索引；
根据槽索引找到槽函数，执行槽函数。 
详见： qt之信号与槽的原理

# 4 Qt信号和槽的本质是什么
回调函数。
信号或是传递值，或是传递动作变化；
槽函数响应信号或是接收值，或者根据动作变化来做出对应操作。

# 5 Qt信号槽机制的优势和不足

优点：类型安全，松散耦合。
缺点：同回调函数相比，运行速度较慢。 

优点：

类型安全：需要关联的信号槽的签名必须是等同的。即信号的参数类型和参数个数同接受该信号的槽的参数类型和参数个数相同。
若信号和槽签名不一致，则编译器会报错。

松散耦合：信号和槽机制减弱了Qt对象的耦合度。
激发信号的Qt对象无需知道是哪个对象的那个槽接收它发出的信号，它只需要在适当的时间发送适当的信号即可，而不需要关心是否被接收和哪个对象接收了。

Qt保证适当的槽得到了调用，即使关联的对象在运行时删除，程序也不会崩溃。

灵活性：一个信号关联多个槽，多个信号关联同一个槽。

缺点：
速度较慢：与回调函数相比，信号和槽机制运行速度比直接调用非虚函数慢10倍左右。 

原因：
需要定位接收信号的对象。
安全地遍历所有槽。
编组，解组传递参数。

多线程的时候，信号需要排队等候。

与创建对象的new及delete相比，信号和槽的运行代价只是他们很少的一部分。
信号和槽机制导致的这点性能损失，对于实时应用程序是可以忽略的。

# 6 信号与槽、函数指针

回调函数使用函数指针来实现的，如果多个类都关注一个类的动态变化，这样就会需要写出一个比较长的列表来管理这些类之间的关系。

QT使用信号与槽来解决这个连接问题，这种方式比较清晰简单一些，一个类只需要清楚槽函数、信号，然后将信号与槽进行连接，QT会自己处理函数的调用关系。

这样在软件设计角度更加的清晰，灵活，不容易出错。 

Qt信号与槽机制降低了Qt对象的耦合度。发信号的对象不需要知道有几个槽函数，也不需要关系是否收到信号，或者谁收到了，谁没收到。同样的槽函数也不需要知道谁是信号的发出者。信号只需要在合适的时机发出即可，降低了对象之间的耦合度。

参考： 信号槽机制与回调函数的区别

# 7、Qt 的事件过滤器
父窗口类通过重写eventFilter方法来监听子控件的相关事件进行处理。 
使用这种方式的好处是不需要通过重写控件的方式获取某些事件，对于安装了事件过滤器的对象，他们所有的事件都会经过这个事件过滤器，所以就可以直接在父窗口中进行监测。

比如某个窗口中有个QLabel对象，我们想要监听他的鼠标点击事件，那我们就需要继承QLabel类，然后重写mousePressEvent事件，如果有其他类型的控件也需要获取某个事件，那是不是都需要继续控件并重写某个事件了，所以我们通过事件过滤器就可以很方便获取某个对象的某个事件。

专门的事件过滤器类，对特定的对象/特定的事件进行处理。 

事件过滤器类只需对当前安装的对象进行处理，无需关心其他操作，且一个事件过滤器类可以被多个对象使用，例如Qt文档中的按键过滤示例，KeyPressEater类中的eventFilter过滤了所有的键盘按下事件，只要安装此事件过滤器的控件，都接收不到键盘按键按下的事件，这种就是对某个通用的事件进行过滤，可以进行多次复用。
给QApplication安装事件过滤器，达到全局事件监听的效果。 在notify方法下发事件的时候，QApplication对象可以拿到第一控制权，对某些事件优先进行处理，比如全局的快捷键操作。
注意点:

事件过滤器可以安装在任何继承QObject的对象上，也可以安装在QApplication对象上（全局事件过滤器）；
事件过滤器(eventFilter方法)返回值为true，表示将当前事件进行过滤，不会发送到对象本身；如果返回false，表示对当前事件不做任何处理，会通过event()方法将事件分发给原来的对象。如果不知道怎么处理或者返回什么，那就返回父类的eventFilter方法（类似 return QObject::eventFilter(watched, event)）;
一个对象可以安装多个事件过滤器（也就是一个对象的事件可以被多个对象进行监控/处理/过滤）， 并且最先安装的事件过滤器是最后被调用的，类似于栈的操作，先进后出；
一个事件过滤器可以被多个对象安装，但是如果在事件过滤器(eventFilter方法)中把该对象删除了， 一定要将返回值设为true。否则 Qt会将事件继续分发给这个对象，从而导致程序崩溃。
详见： Qt之事件过滤器（eventFilter）详解



# 9、信号与槽的多种用法
一个信号 -> 多个槽 
这时槽的执行顺序和在不在同一个线程上有关，同一线程，槽的执行顺序和声明顺序有关，跨线程时，执行顺序是不确定的。
多个信号 -> 一个槽 
只要任意一个信号发出，这个槽就会被调用。
一个信号 -> 另一个信号 
当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。

槽可以被取消链接 这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。想主动取消连接就用disconnect()函数中添加任何实现。
使用Lambda 表达式 在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。


# 10、Qt connect 函数的连接方式
Qt::AutoConnection： 默认值，使用这个值则连接类型会在信号发送时决定。如果接收者和发送者在同一个线程，则自动使用Qt::DirectConnection类型。如果接收者和发送者不在一个线程，则自动使用Qt::QueuedConnection类型。
Qt::DirectConnection：槽函数会在信号发送的时候直接被调用，槽函数和信号发送者在同一线程。效果看上去就像是直接在信号发送位置调用了槽函数，效果上看起来像函数调用，同步执行。 emit语句后面的代码将在与信号关联的所有槽函数执行完毕后才被执行。
Qt::QueuedConnection：信号发出后，信号会暂时被放到一个消息队列中，需等到接收对象所属线程的事件循环取得控制权时才取得该信号，然后执行和信号关联的槽函数，这种方式既可以在同一线程内传递消息也可以跨线程操作。 emit语句后的代码将在发出信号后立即被执行，无需等待槽函数执行完毕
Qt::BlockingQueuedConnection：槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。而且接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。
Qt::UniqueConnection：这个flag可以通过按位或（|）与以上四个结合在一起使用。当这个flag设置时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是为了避免重复连接。

# 11、事件与信号的区别
使用场合和时机不同 一般情况下，在“使用”窗口部件时，我们经常需要使用信号，并且会遵循信号与槽的机制；而在“实现”窗口部件时，我们就不得不考虑如何处理事件了。举个例子，当使用 QPushButton 时，我们对于它的 clicked()信号往往更为关注，而很少关心促成发射该信号的底层的鼠标或者键盘事件。

但是，如果要实现一个类似于 QPushButton 的类，我们就需要编写一定的处理鼠标和键盘事件的代码，而且在必要的时候，仍然需要发射和接收 clicked()信号。

使用的机制和原理不同 事件类似于 Windows 里的消息，它的发出者一般是窗口系统。相对信号和槽机制，它 比较“底层”，它同时支持异步和同步的通信机制，一个事件产生时将被放到事件队列 里，然后我们就可以继续执行该事件 “后面”的代码。事件的机制是非阻塞的。 

信号和槽机制相对而言比较“高层”，它的发出者一般是对象。从本质上看，它类似 于传统的回调机制，是不支持异步调用的。

# 12、信号与槽机制需要注意的问题

信号与槽的效率是非常高的，但是同真正的回调函数比较起来，由于增加了灵活 性，因此在速度上还是有所损失，当然这种损失相对来说是比较小的，通过在一台 i586- 133 的机器上测试是 10 微秒（运行 Linux），可见这种机制所提供的简洁性、灵活性还是 值得的。但如果我们要追求高效率的话，比如在实时系统中就要尽可能的少用这种机制。

信号与槽机制与普通函数的调用一样，如果使用不当的话，在程序执行时也有可能 产生死循环。因此，在定义槽函数时一定要注意避免间接形成无限循环，即在槽中再次发射 所接收到的同样信号。

如果一个信号与多个槽相关联的话，那么，当这个信号被发射时，与之相关的槽被 激活的顺序将是随机的，并且我们不能指定该顺序。

宏定义不能用在 signal 和 slot 的参数中。
构造函数不能用在 signals 或者 slots 声明区域内。
函数指针不能作为信号或槽的参数。
信号与槽不能有缺省参数。
信号与槽也不能携带模板类参数。

所有的信号都没有返回值，所以返回值都用void。
所有的信号都不需要定义。
必须直接或间接继承自QOBject类，并且开头私有声明包含Q_OBJECT。

在同一个线程中，当一个信号被emit发出时，会立即执行其槽函数，等槽函数执行完毕后，才会执行emit后面的代码，如果一个信号链接了多个槽，那么会等所有的槽函数执行完毕后才执行后面的代码，槽函数的执行顺序是按照它们链接时的顺序执行的。不同线程中（即跨线程时），槽函数的执行顺序是随机的。

在链接信号和槽时，可以设置链接方式为：在发出信号后，不需要等待槽函数执行完，而是直接执行后面的代码，是通过connect的第5个参数。
信号与槽机制要求信号和槽的参数一致，所谓一致，是参数类型一致。
如果不一致，允许的情况是，信号的参数可以比槽函数的参数多，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。

这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。


# 15、描述QT中的文件流(QTextStream)和数据流(QDataStream)的区别
文件流(QTextStream):操作轻量级数据（int,double,QString）数据写入文本件中以后以文本的方式呈现。 

数据流(QDataStream):通过数据流可以操作各种数据类型，包括对象，存储到文件中数据为二进制。 
文件流，数据流都可以操作磁盘文件，也可以操作内存数据。通过流对象可以将对象打包到内存，进行数据的传输。

# 16、QT 保证多线程安全
互斥量（QMutex） QMutex m_Mutex; m_Mutex.lock(); m_Mutex.unlock();

互斥锁（QMutexLocker） QMutexLocker mutexLocker(&m_Mutex); 从声明处开始（在构造函数中加锁），出了作用域自动解锁（在析构函数中解锁）。

等待条件（QWaitCondition） QWaitCondtion m_WaitCondition; m_WaitConditon.wait(&m_muxtex, time);
m_WaitCondition.wakeAll();

QReadWriteLock类 》一个线程试图对一个加了读锁的互斥量进行上读锁，允许； 》一个线程试图对一个加了读锁的互斥量进行上写锁，阻塞； 》一个线程试图对一个加了写锁的互斥量进行上读锁，阻塞；、 》一个线程试图对一个加了写锁的互斥量进行上写锁，阻塞。 读写锁比较适用的情况是：需要多次对共享的数据进行读操作的阅读线程。 QReadWriterLock 与QMutex相似，除了它对 "read","write"访问进行区别对待。它使得多个读者可以共时访问数据。使用QReadWriteLock而不是QMutex，可以使得多线程程序更具有并发性。

信号量QSemaphore 但是还有些互斥量（资源）的数量并不止一个，比如一个电脑安装了2个打印机，我已经申请了一个，但是我不能霸占这两个，你来访问的时候如果发现还有空闲的仍然可以申请到的。于是这个互斥量可以分为两部分，已使用和未使用。

QReadLocker类和QWriteLocker类对QReadWriteLock进行加解锁


# 8、为什么 new QWidget 不需要 delete
Qt提供了一种机制，能够自动、有效的组织和管理继承自QObject的Qt对象，这种机制就是对象树。 
当我们创建一个QObject对象时，可以指定其父对象（也被称为父控件），加入到父对象的子对象（也被称为子控件）列表中。
当父对象被析构时，这个列表中的所有子对象会被析构。
当某个QObject对象被析构时，它会将自己从父对象的列表中删除，以避免父对象被析构时，再次析构自己。

 详见： Qt编程中new出来的控件为什么没有delete

# 17、详解Qt中的内存管理机制
所有继承自QOBJECT类的类，如果在new的时候指定了父亲，那么它的清理时在父亲被delete的时候delete的，所以如果一个程序中，所有的QOBJECT类都指定了父亲，那么他们是会一级级的在最上面的父亲清理时被清理，而不用自己清理；

程序通常最上层会有一个根的QOBJECT，就是放在setCentralWidget（）中的那个QOBJECT，这个QOBJECT在 new的时候不必指定它的父亲，因为这个语句将设定它的父亲为总的QAPPLICATION，当整个QAPPLICATION没有时它就自动清理，所以也无需清理。

这是有人可能会问那如果我自行delete掉这些QT接管负责销毁的指针了会出现什么情况呢，如果时这样的话，正常情况下QT的拥有这个对象的那个父亲会知道这件事情，它会直到它的儿子被你直接DELETE了，这样它会将这个儿子移出它的列表，并且重新构建显示内容，但是直接这样做时有风险的！

也就是要说的下一条

当一个QOBJECT正在接受事件队列时如果中途被你DELETE掉了，就是出现问题了，所以QT中建议大家不要直接DELETE掉一个 QOBJECT，如果一定要这样做，要使用QOBJECT的deleteLater()函数，它会让所有事件都发送完一切处理好后马上清除这片内存，而且就算调用多次的deletelater也不会有问题。

QT不建议在一个QOBJECT 的父亲的范围之外持有对这个QOBJECT的指针，因为如果这样外面的指针很可能不会察觉这个QOBJECT被释放，会出现错误，如果一定要这样，就要记住你在哪这样做了，然后抓住那个被你违规使用的QOBJECT的destroyed（）信号，当它没有时赶快置零你的外部指针。当然我认为这样做是及其麻烦也不符合高效率编程规范的，所以如果要这样在外部持有QOBJECT的指针，建议使用引用或者用智能指针，如QT就提供了智能指针针对这些情况，见***一条。

QT中的智能指针封装为QPointer类，所有QOBJECT的子类都可以用这个智能指针来包装，很多用法与普通指针一样，可以详见QT assistant 通过调查这个QT的内存管理功能 虽然这个QT弄的有点小复杂，但是使用起来还是很方便的。 

详见： 详解Qt中的内存管理机制

