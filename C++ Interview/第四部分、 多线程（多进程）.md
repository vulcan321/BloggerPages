第四部分、 多线程（多进程） 相关
1、线程与进程的区别
线程与进程的比较如下：

进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
线程能减少并发执行的时间和空间开销；
对于，线程相比进程能减少开销，体现在：

线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
线程的终止时间比进程快，因为线程释放的资源相比进程少很多；
同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；
所以，线程比进程不管是时间效率，还是空间效率都要高。
进程之间私有和共享的资源
私有：地址空间、堆、全局变量、栈、寄存器
共享：代码段，公共数据，进程目录，进程 ID
线程之间私有和共享的资源
私有：线程栈，寄存器，程序计数器
共享：堆，地址空间，全局变量，静态变量

2、什么是线程不安全?
在随机调度之下,线程执行有多种可能,其中某些可能会导致代码出bug就称为线程不安全.

3、造成线程不安全的原因
操作系统的随机调度/抢占式执行(万恶之源)–>无法改变
多个线程修改同一个变量(一个字都不能少)—>尽量避免
有些修改操作,不是原子的!(不可拆分的最小单位,就叫原子 即对应一条机器指令)—>通过加锁操作,把指令打包
内存可见性问题(内存改了,但是在优化的背景下,读不到,看不见)
如:线程1一直在读取硬盘上的资源再判断,在多次读取硬盘并获得相同的结果后编译器会认为这样的做法过于低效,然后就会省略读取的过程,一直判断,若此时有线程2需要这个判断结果(读取到数据后的判断结果)就会出现问题.
指令重排序(也是编译器,操作系统等的优化,调整了代码的执行顺序)
最常见的就是对象new的问题：
分为三步:1.创建内存空间 2.往内存空间上构造对象 3.把这个内存的引用赋值给你要创建的变量
有时候编译器会认为先执行3或者先执行2最高效,就会出现指令顺序倒转的问题,这时另一个线程尝试读取变量的引用就会出现问题

4、C++线程中的几类锁
线程之间的锁有： 互斥锁、条件锁、自旋锁、读写锁、递归锁。一般而言，锁的功能与性能成反比（详见C++11线程中的几种锁、如何理解互斥锁、条件锁、读写锁以及自旋锁？）

5、什么是死锁，解决方式
死锁：死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局，若无外力作用，这些进程（线程）都将无法向前推进。
详见： 死锁四个必要条件及死锁的预防、检测、避免、解除

6、进程之间的通信方式
管道（PIPE）
（1）有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
①优点：可以实现任意关系的进程间的通信
②缺点：a、长期存于系统中，使用不当容易出错；b、缓冲区有限
（2）无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
①优点：简单方便
②缺点：a、局限于单向通信；b、只能创建在它的进程以及其有亲缘关系的进程之间；c、缓冲区有限

信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问
①优点：可以同步进程
②缺点：信号量有限

信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识
①优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
②缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合

共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
①优点：无须复制，快捷，信息量大
②缺点：a、通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题；b、利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信

套接字（Socket）：可用于不同计算机间的进程通信
①优点：
a、传输数据为字节级，传输数据可自定义，数据量小效率高；
b、传输数据时间短，性能高；
c、适合于客户端和服务器端之间信息实时交互；
d、可以加密,数据安全性强；
②缺点：需对传输的数据进行解析，转化成应用级的数据。
更多详见 C++基础语法梳理：进程与线程！知识点详细梳理

7、线程之间的通信方式
锁机制
包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）

互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。
读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。
自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。
条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
信号量机制(Semaphore)

无名线程信号量
命名线程信号量
信号机制(Signal)：类似进程间的信号处理
屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。
线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制
