


第一部分、 C++ 基础

1、C和C++的区别
C是面向过程的语言，是一个结构化的语言，考虑如何通过一个过程对输入进行处理得到输出；C++是面向对象的语言，主要特征是“封装、继承和多态”。封装隐藏了实现细节，使得代码模块化；派生类可以继承父类的数据和方法，扩展了已经存在的模块，实现了代码重用；多态则是“一个接口，多种实现”，通过派生类重写父类的虚函数，实现了接口的重用。
C和C++动态管理内存的方法不一样，C是使用malloc/free，而C++除此之外还有new/delete关键字。
C++中有引用，C中不存在引用的概念

2、C++中指针和引用的区别
指针有自己的一块空间，而引用只是一个别名；
使用 sizeof 看一个指针的大小为4字节（32位，如果要是64位的话指针为8字节），而引用则是被引用对象的大小；
指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用；
作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；
指针在使用中可以指向其他对象，但是引用只能是一个对象的引用，不能被改变；
指针可以是多级，而引用没有分级；
如果返回动态分配内存的对象或者内存，必须使用指针，引用可能引起内存泄漏。
引用占用内存空间吗？
对引用取地址，其实是取的引用所对应的内存空间的地址。这个现象让人觉得引用好像并非一个实体。但是引用是占用内存空间的，而且其占用的内存和指针一样，因为引用的内部实现就是通过指针来完成的。

3、结构体struct和共同体union（联合）的区别
结构体：将不同类型的数据组合成一个整体，是自定义类型
共同体：不同类型的几个变量共同占用一段内存

结构体中的每个成员都有自己独立的地址，它们是同时存在的；
共同体中的所有成员占用同一段内存，它们不能同时存在；
sizeof(struct)是内存对齐后所有成员长度的总和，sizeof(union)是内存对齐后最长数据成员的长度。
结构体为什么要内存对齐呢？

平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
硬件原因：经过内存对齐之后，CPU的内存访问速度大大提升。

4、struct 和 class 的区别？
首先说一下C中的结构体和C++中的结构体的异同：
在这里插入图片描述
C++中 struct 与 class 的区别：
内部成员变量及成员函数的默认访问属性：struct 默认防控属性是 public 的，而 class 默认的访问属性是private的
继承关系中默认访问属性的区别：在继承关系，struct 默认是 public 的，而 class 是 private
class这个关键字还可用于定义模板参数，就等同于 typename；而strcut不用与定义模板参数


5、#define和const的区别
#define定义的常量没有类型，所给出的是一个立即数；const定义的常量有类型名字，存放在静态区域
处理阶段不同，#define定义的宏变量在预处理时进行替换，可能有多个拷贝，const所定义的变量在编译时确定其值，只有一个拷贝。
#define定义的常量是不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址
#define可以定义简单的函数，const不可以定义函数

6、重载overload，覆盖（重写）override，隐藏（重定义）overwrite，这三者之间的区别
overload，将语义相近的几个函数用同一个名字表示，但是参数列表（参数的类型，个数，顺序不同）不同，这就是函数重载，返回值类型可以不同
特征：相同范围（同一个类中）、函数名字相同、参数不同、virtual关键字可有可无
override，派生类覆盖基类的虚函数，实现接口的重用，返回值类型必须相同
特征：不同范围（基类和派生类）、函数名字相同、参数相同、基类中必须有virtual关键字（必须是虚函数）
overwrite，派生类屏蔽了其同名的基类函数，返回值类型可以不同
特征：不同范围（基类和派生类）、函数名字相同、参数不同或者参数相同且无virtual关键字
7、new 和 delete 是如何实现的，与 malloc 和 free有什么异同？
new操作针对数据类型的处理，分为两种情况：

简单数据类型（包括基本数据类型和不需要构造函数的类型）
简单类型直接调用 operator new 分配内存；
可以通过new_handler 来处理 new 失败的情况；
new 分配失败的时候不像 malloc 那样返回 NULL，它直接抛出异常（bad_alloc）。要判断是否分配成功应该用异常捕获的机制；
复杂数据类型（需要由构造函数初始化对象）
new 复杂数据类型的时候先调用operator new，然后在分配的内存上调用构造函数。
delete也分为两种情况：

简单数据类型（包括基本数据类型和不需要析构函数的类型）
delete简单数据类型默认只是调用free函数。
复杂数据类型（需要由析构函数销毁对象）
delete复杂数据类型先调用析构函数再调用operator delete。
与 malloc 和 free 的区别：

属性上：new / delete 是c++关键字，需要编译器支持。 malloc/free是库函数，需要c的头文件支持。
参数：使用new操作符申请内存分配时无须制定内存块的大小，编译器会根据类型信息自行计算。而mallco则需要显式地指出所需内存的尺寸。
返回类型：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，故new是符合类型安全性的操作符。而malloc内存成功分配返回的是void *，需要通过类型转换将其转换为我们需要的类型。
分配失败时：new内存分配失败时抛出bad_alloc异常；malloc分配内存失败时返回 NULL。
自定义类型：new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。 malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
重载：C++允许重载 new/delete 操作符。而malloc为库函数不允许重载。
内存区域：new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。其中自由存储区为：C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。
既然有了malloc/free，C++中为什么还需要new/delete呢？
运算符是语言自身的特性，有固定的语义，编译器知道意味着什么，由编译器解释语义，生成相应的代码。库函数是依赖于库的，一定程度上独立于语言的。编译器不关心库函数的作用，只保证编译，调用函数参数和返回值符合语法，生成call函数的代码。
对于非内部数据类型而言，光用malloc/free无法满足动态对象都要求。new/delete是运算符，编译器保证调用构造和析构函数对对象进行初始化/析构。但是库函数malloc/free是库函数，不会执行构造/析构。

8、delete和delete[]的区别
delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数
用new分配的内存用delete释放，用new[]分配的内存用delete[]释放

9、const知道吗？解释一下其作用
const修饰类的成员变量，表示常量不可能被修改
const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数
const函数只能调用const函数，非const函数可以调用const函数

10、关键字static的作用
函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值
模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内
类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝
类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量
注意和const的区别！！！const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象
11、堆和栈的区别
堆栈空间分配区别：
栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；
堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。
堆栈的缓存方式区别
栈：是内存中存储值类型的，大小为2M（window，linux下默认为8M，可以更改），超出则会报错，内存溢出；
堆：内存中，存储的是引用数据类型，引用数据类型无法确定大小，堆实际上是一个在内存中使用到内存中零散空间的链表结构的存储空间，堆的大小由引用类型的大小直接决定，引用类型的大小的变化直接影响到堆的变化。
堆栈数据结构上的区别
堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
栈（数据结构）：一种先进后出的数据结构。
C++内存区域中堆和栈的区别：
管理方式不同：栈是由编译器自动管理，无需我们手工控制；对于堆来说，释放由程序员完成，容易产生内存泄漏。
空间大小不同：一般来讲，在32为系统下面，堆内存可达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定空间大小的，例如，在vc6下面，默认的栈大小好像是1M。当然，也可以自己修改：打开工程。 project–>setting–>link，在category中选中output，然后再reserve中设定堆栈的最大值和 commit。
能否产生碎片：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题。
生长方向不同：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方式是向下的，是向着内存地址减小的方向增长。
分配方式不同：堆都是动态分配的；栈静态分配由编译器完成，比如局部变量的分配
分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是c/c++库函数提供的，机制很复杂。库函数会按照一定的算法进行分配。显然，堆的效率比栈要低得多。
进程内存中的映像，主要有代码区，堆（动态存储区，new/delete的动态数据），栈，静态存储区

堆和自由存储区的区别？
总的来说，堆是C语言和操作系统的术语，是操作系统维护的一块动态分配内存；自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。他们并不是完全一样。
从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。
扩展: 堆和栈的区别（转过无数次的文章）

12、#include<file.h> #include “file.h” 的区别
前者是从标准库路径寻找
后者是从当前工作路径

13、什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？
动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。
方法：malloc/free要配套，对指针赋值的时候应该注意被赋值的指针是否需要释放；使用的时候记得指针的长度，防止越界

14、定义和声明的区别
为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。
加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。

15、C++文件编译与执行的四个阶段
预处理：根据文件中的预处理指令来修改源文件的内容
编译：编译成汇编代码
汇编：把汇编代码翻译成目标机器指令
链接：链接目标代码生成可执行程序
16、C++的内存管理
在C++中，内存被分成五个区：栈、堆、自由存储区、静态存储区、常量区
栈：存放函数的参数和局部变量，编译器自动分配和释放
堆：new关键字动态分配的内存，由程序员手动进行释放，否则程序结束后，由操作系统自动进行回收
自由存储区：new所申请的内存则是在自由存储区上，使用delete来释放。

堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。
全局/静态存储区：存放全局变量和静态变量
常量区：存放常量，不允许被修改

17、 C++的四种强制转换
类型转化机制可以分为隐式类型转换和显示类型转化（强制类型转换）
(new-type) expression
new-type (expression)
隐式类型转换比较常见，在混合类型表达式中经常发生；四种强制类型转换操作符：
static_cast、dynamic_cast、const_cast、reinterpret_cast

static_cast ：编译时期的静态类型检查static_cast静态转换相当于C语言中的强制转换，但不能实现普通指针数据（空指针除外）的强制转换，一般用于父类和子类指针、引用间的相互转换。没有运行时类型检查来保证转换的安全性。
①用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。不管是否发生多态，父子之间互转时，编译器都不会报错。

进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的，但是编译器不会报错。
②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
③把空指针转换成目标类型的空指针。
④把任何指针类型转换成空指针类型。
⑤可以对普通数据的const和non_const进行转换，但不能对普通数据取地址后的指针进行const添加和消去。
⑥无继承关系的自定义类型，不可转换，不支持类间交叉转换。
另外，static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)。
2. dynamic_cast：运行时的检查
动态转换的类型和操作数必须是完整类类型或空指针、空引用，说人话就是说，只能用于类间转换，支持类间交叉转换，不能操作普通数据。
主要用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换，
①进行上行转换（把派生类的指针或引用转换成基类表示）是安全的，允许转换；
②进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的，不允许转化，编译器会报错；
③发生多态时，允许互相转换。
④无继承关系的类之间也可以相互转换，类之间的交叉转换。
⑤如果dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个std::bad_cast异常
3. const_cast
const_cast用于强制去掉不能被修改的常数特性，其去除常量性的对象一般为指针或引用。
4. reinterpret_cast
在C++语言中，reinterpret_cast主要有几种强制转换用途：将指针或引用转换为一个足够长度的整型、将整型转换为指针或引用类型。
更详细见 C++的四种强制转换
5. 为什么不使用C的强制转换 ？
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

18、extern“C”作用
extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。

19、typdef和define区别
#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查
typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名
typedef (int*) pINT;
#define pINT2 int*
效果相同？实则不同！实践中见差别：pINT a,b;的效果同int *a; int *b;表示定义了两个整型指针变量。而pINT2 a,b;的效果同int *a, b;表示定义了一个整型指针变量a和整型变量b。

20、引用作为函数参数以及返回值的好处
对比值传递，引用传参的好处：

在函数内部可以对此参数进行修改
提高函数调用和运行的效率（所以没有了传值和生成副本的时间和空间消耗）
值传递：
形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。
指针传递：
形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作
引用传递：
形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。
但是有以下的限制：

不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁
不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak
可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。
21、什么是野指针
野指针不是NULL指针，是未初始化或者未清零的指针，它指向的内存地址不是程序员所期望的，可能指向了受限的内存。
成因：

指针变量没有被初始化
指针指向的内存被释放了，但是指针没有置NULL
指针超过了变量了的作用范围，比如b[10]，指针b+11
22、C++中内存泄漏的几种情况
内存泄漏是指动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

类的构造函数和析构函数中new和delete没有配套
在释放对象数组时没有使用delete[]，使用了delete
没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露
没有正确的清楚嵌套的对象指针
23、栈溢出的原因以及解决方法
栈溢出是指函数中的局部变量造成的溢出（注：函数中形参和函数中的局部变量存放在栈上）
栈的大小通常是1M-2M,所以栈溢出包含两种情况，一是分配的的大小超过栈的最大值，二是分配的大小没有超过最大值，但是接收的buf比原buf小。

函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈
局部变量体积太大。
解决办法大致说来也有两种：

增加栈内存的数目；如果是不超过栈大小但是分配值小的，就增大分配的大小
使用堆内存；具体实现由很多种方法可以直接把数组定义改成指针,然后动态申请内存;也可以把局部变量变成全局变量,一个偷懒的办法是直接在定义前边加个static,呵呵,直接变成静态变量(实质就是全局变量)
24、左值和右值
不是很严谨的来说，左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)。举例来说我们定义的变量 a 就是一个左值，而malloc返回的就是一个右值。或者左值就是在程序中能够寻址的东西，右值就是一个具体的真实的值或者对象，没法取到它的地址的东西(不完全准确)，因此没法对右值进行赋值，但是右值并非是不可修改的，比如自己定义的class, 可以通过它的成员函数来修改右值。
归纳一下就是：
可以取地址的，有名字的，非临时的就是左值
不能取地址的，没有名字的，临时的，通常生命周期就在某个表达式之内的就是右值
但是到了 C++11 之后概念变的略微复杂，引入了 lvalue, glvalue, rvalue, xvalue 和 prvalue。

25、左值引用与右值引用
左值引用就是我们通常所说的引用，如下所示。左值引用通常可以看作是变量的别名。

type-id & cast-expression 
```cpp
// demo
int a = 10
int &b = a

int &c = 10	// 错误，无法对一个立即数做引用

const int &d = 10	// 正确， 常引用引用常数量是ok的，其等价于 const int temp = 10; const int &d = temp	
```

右值引用是 C++11 新增的特性，其形式如下所示。右值引用用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期。

右值引用支持移动语义的实现，可以减少拷贝，提升程序的执行效率。
右值引用可以使重载函数变得更加简洁。右值引用可以适用 const T& 和 T& 形式的参数。
type-id && cast-expression  
```
// demo
int &&var = 10;	// ok

int a = 10
int &&b = a	// 错误， a 为左值

int &&c = var	// 错误，var 为左值

int &&d = move(a)	// ok, 通过move得到左值的右值引用
```

在汇编层面右值引用做的事情和常引用是相同的，即产生临时量来存储常量。但是，唯一 一点的区别是，右值引用可以进行读写操作，而常引用只能进行读操作。

26、头文件中的 ifndef/define/endif 是干什么用的? 该用法和 program once 的区别？
相同点： 它们的作用是防止头文件被重复包含。
不同点：

ifndef 由语言本身提供支持，但是 program once 一般由编译器提供支持，也就是说，有可能出现编译器不支持的情况(主要是比较老的编译器)。
通常运行速度上 ifndef 一般慢于 program once，特别是在大型项目上， 区别会比较明显，所以越来越多的编译器开始支持 program once。
ifndef 作用于某一段被包含（define 和 endif 之间）的代码， 而 program once 则是针对包含该语句的文件， 这也是为什么 program once 速度更快的原因。
如果用 ifndef 包含某一段宏定义，当这个宏名字出现“撞车”时，可能会出现这个宏在程序中提示宏未定义的情况（在编写大型程序时特别需要注意，因为有很多程序员在同时写代码）。相反由于program once 针对整个文件， 因此它不存在宏名字“撞车”的情况， 但是如果某个头文件被多次拷贝，program once 无法保证不被多次包含，因为program once 是从物理上判断是不是同一个头文件，而不是从内容上。
27、指针数组和数组指针的区别
数组指针，是指向数组的指针，而指针数组则是指该数组的元素均为指针。

数组指针，是指向数组的指针，其本质为指针，形式如下。如 int (*p)[n]，p即为指向数组的指针，()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。数组指针是指向数组首元素的地址的指针，其本质为指针，可以看成是二级指针。
类型名 (*数组标识符)[数组长度]
1
指针数组，在C语言和C++中，数组元素全为指针的数组称为指针数组，其中一维指针数组的定义形式如下。指针数组中每一个元素均为指针，其本质为数组。如 int p[n]， []优先级高，先与p结合成为一个数组，再由int说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 p=a; 这里p表示指针数组第一个元素的值，a的首地址的值。
类型名 *数组标识符[数组长度]
1
28、C++是不是类型安全的？
不是。两个不同类型的指针之间可以强制转换

29、main函数执行之前，还会执行什么代码？
全局对象的构造函数会在main函数之前执行。

30、全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？
生命周期不同：
全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；
使用方式不同：
通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。
内存分配位置不同：
全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

31、关于sizeof小结的。
答：sizeof计算的是在栈中分配的内存大小。

sizeof不计算static变量占得内存；
32位系统的指针的大小是4个字节，64位系统的指针是8字节，而不用管指针类型；
char型占1个字节，int占4个字节，short int占2个字节
long int占4个字节，float占4字节，double占8字节，string占4字节
一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节
数组的长度：
若指定了数组长度，则不看元素个数，总字节数=数组长度*sizeof（元素类型）
若没有指定长度，则按实际元素个数类确定
Ps：若是字符数组，则应考虑末尾的空字符。
结构体对象的长度
在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便以结构体内最长的数据元素的长度为对齐单位，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。
unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsigned int）=4
自定义类型的sizeof取值等于它的类型原型取sizeof
对函数使用sizeof，在编译阶段会被函数的返回值的类型代替
sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符
当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸
32、sizeof 和 strlen 的区别？
sizeof 是一个操作符， strlen 是库函数。
sizeof 的参数可以是数据的类型， 也可以是变量； 而 strlen 只能以结尾为 ‘\0’ 的字符串做参数。
数组做 siezeof 的参数不退化，传递给 strlen 就退化为指针了。
编译器在编译时就计算出了 sizeof 的结果， 而 strlen 函数必须在运行时才能计算出来。 而且 sizeof 计算的是数据类型占内存的大小， 而 strlen 计算的是字符串实际的长度
33、说说内联函数
函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。
为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。
详见： C++ inline内联函数详解

34、C/C++的存储期
C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。
详见： C/C++的存储期

35、流操作符重载为什么返回引用
在程序中，流操作符>>和<<经常连续使用。因此这两个操作符的返回值应该是一个仍旧支持这两个操作符的流引用。其他的数据类型都无法做到这一点。
注意：除了在赋值操作符和流操作符之外的其他的一些操作符中，如+、-、*、/等却千万不能返回引用。因为这四个操作符的对象都是右值，因此，它们必须构造一个对象作为返回值。

36、全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？
生命周期不同：
全局变量随主程序创建和创建，随主程序销毁而销毁
局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在； 内存中分配在全局数据区
使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用，分配在栈区
操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

第二部分、 c++ 类相关
1、什么是面向对象（OOP）？面向对象的意义？
Object Oriented Programming, 面向对象是一种对现实世界理解和抽象的方法、思想，通过将需求要素转化为对象进行问题处理的一种思想。其核心思想是数据抽象（封装）、继承和动态绑定（多态）。
面向对象的意义在于：将日常生活中习惯的思维方式引入程序设计中；将需求中的概念直观的映射到解决方案中；以模块为中心构建可复用的软件系统；提高软件产品的可维护性和可扩展性。

2、解释下封装、继承和多态？
封装：
封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。
封装的意义在于保护或者防止代码（数据）被我们无意中破坏。
从封装的角度看，public， private 和 protected 属性的特点如下。

不管哪种属性，内类都是可以访问的
public 是一种暴露的手段，比如暴露接口，类的对象可以访问
private 是一种隐藏的手段，类的对象不能访问
protected 成员：
和 public 一样可以被子类继承
和 private 一样不能在类外被直接调用
特例：在衍生类中可以通过衍生类对象访问
继承：
继承主要实现重用代码，节省开发时间。
子类可以继承父类的一些东西。

a.公有继承(public) 公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态（基类的私有成员仍然是私有的，不能被这个派生类的子类所访问）。
b.私有继承(private) 私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员（并且不能被这个派生类的子类所访问）。
c.保护继承(protected) 保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员（并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的）。
这里特别提一下虚继承。虚继承是解决C++多重继承问题（其一，浪费存储空间；第二，存在二义性问题）的一种手段。比如菱形继承，典型的应用就是 iostream, 其继承于 istream 和 ostream，而 istream 和 ostream 又继承于 ios。
多态：
多态是指通过基类的指针或者引用，在运行时动态调用实际绑定对象函数的行为。与之相对应的编译时绑定函数称为静态绑定。多态是设计模式的基础，多态是框架的基础。
C++静态多态与动态多态

3、构造函数和析构函数的执行顺序？
构造函数：

首先调用父类的构造函数；
调用成员变量的构造函数；
调用类自身的构造函数。
析构函数
对于栈对象或者全局对象，调用顺序与构造函数的调用顺序刚好相反，也即后构造的先析构。对于堆对象，析构顺序与delete的顺序相关。

4、虚函数是怎么实现的
每一个含有虚函数的类都至少有有一个与之对应的虚函数表，其中存放着该类所有虚函数对应的函数指针（地址），
类的示例对象不包含虚函数表，只有虚指针；
派生类会生成一个兼容基类的虚函数表。
阅读： C++虚函数及虚函数表解析

5、 构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？
构造函数不能声明为虚函数
1). 因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等
2). 虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了
析构函数最好声明为虚函数
首先析构函数可以为虚函数，当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。
如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。
子类析构时，要调用父类的析构函数吗？
析构函数调用的次序时先派生类后基类的。和构造函数的执行顺序相反。并且析构函数要是virtual的，否则如果用父类的指针指向子类对象的时候，析构函数静态绑定，不会调用子类的析构。
不用显式调用，会自动调用
6、细看拷贝构造函数
对于 class A，它的拷贝构造函数如下：

A::A(const A &a){}
1
为什么必须是当前类的引用呢？
循环调用。如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。
只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，也是 C++ 语法的要求。

为什么是 const 引用呢？
拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。
另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能直接转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。

7、静态绑定和动态绑定的介绍
静态绑定和动态绑定是C++多态性的一种特性

对象的静态类型和动态类型
由于继承导致对象的指针和引用具有两种不同的类型：静态类型和动态类型。
静态类型：对象在声明时采用的类型，在编译时确定
动态类型：当前对象所指的类型，在运行期决定，对象的动态类型可变，静态类型无法更改
静态绑定和动态绑定
静态绑定：绑定的是对象的静态类型，函数依赖于对象的静态类型，在编译期确定
动态绑定：绑定的是对象的动态类型，函数依赖于对象的动态类型，在运行期确定
只有虚函数才使用的是动态绑定，其他的全部是静态绑定
引用是否能实现动态绑定，为什么引用可以实现
可以。因为引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指的对象的实际类型所定义的。
8、深拷贝和浅拷贝的区别
深拷贝和浅拷贝可以简单的理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，如果资源重新分配了就是深拷贝；反之没有重新分配资源，就是浅拷贝。

9、 什么情况下会调用拷贝构造函数（三种情况）
系统自动生成的构造函数：普通构造函数和拷贝构造函数 （在没有定义对应的构造函数的时候）
生成一个实例化的对象会调用一次普通构造函数，而用一个对象去实例化一个新的对象所调用的就是拷贝构造函数
调用拷贝构造函数的情形：

用类的一个对象去初始化另一个对象的时候
当函数的参数是类的对象时，就是值传递的时候，如果是引用传递则不会调用
当函数的返回值是类的对象或者引用的时候
10、类对象的大小受哪些因素影响？
类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；
内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；
虚函数的话，会在类对象插入vptr指针，加上指针大小；
当该该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。
11、拷贝构造函数和赋值运算符的理解
拷贝构造函数生成新的类对象，而赋值运算符不能。
由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象 是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉。
注 ：当类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符 ，不要使用默认的。

12、C++空类默认有哪些成员函数？
答：默认构造函数、析构函数、复制构造函数、赋值函数

13、如果虚函数是有效的，那为什么不把所有函数设为虚函数？
答：不行。首先，虚函数是有代价的，由于每个虚函数的对象都要维护一个虚函数表，因此在使用虚函数的时候都会产生一定的系统开销，这是没有必要的。

14、构造函数和虚构函数可以是内联函数？
构造函数、析构函数、虚函数可以声明为内联函数，这在语法上是正确的。
编译器并不真正对声明为inline的构造和析构函数内联，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象，调用基类成员对象构造函数等），致使构造函数/析构函数并不像看上去的那么精简。

15、虚函数声明为inline
inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联。

16、C++的空类有哪些成员函数
缺省构造函数。
缺省拷贝构造函数。
缺省析构函数。
缺省赋值运算符。
缺省取址运算符。
缺省取址运算符 const。
注意：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。

17、C++中的五种构造函数
默认构造函数
普通构造函数
拷贝构造函数
转换构造函数
移动构造函数
详见： C++中的五种构造函数






整理的原文
c++面试常见问题汇总—建议收藏
C++常见面试题总结
C/C++ 最常见50道面试题
C++核心知识点汇总(面试)
精选 30 个 C++ 面试题（含解析）
如果你是一个C++面试官，你会问哪些问题？
k6k4中C/C++面试题






参考阅读
十大经典排序，你真的都会了吗？（源码详解）
漫画：“排序算法” 大总结
内存都没了，还能运行程序？
多个线程为了同个资源打起架来了，该如何让他们安分？
Linux 运维故障排查思路，有这篇文章就够了
万字长文！剑指offer全题解思路汇总
我的天！第一次知道操作系统的算法还能这么迷人！
24 张图彻底弄懂九大常见数据结构！
万字长文系统梳理C++函数指针
万字长文图解七道超高频位运算面试题
一口气搞懂「文件系统」，就靠这 25 张图了
看了齐姐这篇文章，再也不怕面试问树了
看完这篇操作系统，和面试官扯皮就没问题了。
史上最全的数据库面试题，面试必刷！
70道C语言与C++常见问答题
c++面试
C++面试题（1）
万字详解我今年经历的腾讯Linux C++ 笔试/面试题及答案
C++开发面试之——C++11新特性20问
腾讯 C++ 笔试/面试题及答案
C++面试——内存管理、堆栈、指针50问
C语言 / C++基础面试知识大集合
50 家公司的 C++ 面经总结，硬核分享！
一文让你搞懂设计模式
这里有60篇硬核文章
超硬核 | 2 万字+20 图带你手撕 STL 容器源码
熬夜整理的万字C/C++总结（一），值得收藏
现代 C++ 教程：高速上手 C++ 11/14/17/20
c++后端开发 资料整理学习