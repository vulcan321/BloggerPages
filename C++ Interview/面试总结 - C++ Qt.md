优化代码的方式

设计模式

Qt Qml 

MVC 模型 视图 控制

线程 async thread 

协作 同步异步

redis 发布订阅模式

stl 的主要内容有哪些

std vector 和qt vector的区别



STL（Standard Template Library，标准模板库）是C++程序设计语言中的一个重要组成部分，其主要内容包括以下几个核心组件：

容器（Containers）：
vector：动态数组，能够自动调整大小，支持随机访问。
list：双向链表，允许高效地在任何位置插入和删除元素。
deque：双端队列，两端都可以高效地进行插入和删除操作。
set / multiset：有序集合，不允许重复元素（multiset允许重复）。
map / multimap：键值对映射，键值有序且不重复（multimap允许键值对应多个值）。
unordered_set / unordered_map：哈希集和哈希映射，基于哈希表实现，无序但查找速度快。


算法（Algorithms）：
提供了一系列通用的算法，如排序（sort()）、查找（find()、binary_search()）、遍历（for_each()）、变换（transform()）、合并（merge()）、复制（copy()）、填充（fill()）等，这些算法通常以迭代器为参数，可以在不同的容器或其他序列容器上进行操作。

迭代器（Iterators）：
迭代器 访问容器内元素的一种统一方式，它是STL中不同组件之间交互的核心工具。根据功能的不同，迭代器有多种类型，例如输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器。
适配器（Adapters）：

用于修改容器或算法的行为，或者将一种类型的容器转换成另一种行为的容器，如stack、queue、priority_queue等。
函数对象（Functors 或 Function Objects）：

在C++中也称为仿函数，它们是重载了operator()的对象，可以用作算法中的谓词或自定义操作。例如，less<>、greater<>等比较函数对象用于排序算法中决定元素之间的相对顺序。

C++17 新特性
C++17 是 C++ 编程语言的重大更新版本，在 C++14 的基础上添加了一系列新特性来增强语言的功能性和便利性，以下是 C++17 中的一些关键特性摘要：

结构化绑定 (Structured Bindings) 允许一次性从复合数据类型（比如结构体、元组、数组等）解构并初始化多个变量，从而简化多值返回和数据访问。

Cpp
struct Point { int x; int y; };
Point p {1, 2};
auto [x, y] = p; // x 现在是 1，y 是 2
折叠表达式 (Fold Expressions) 支持递归模板实例化时的表达式折叠，常用于元编程和变长参数模板的计算。

constexpr if 允许在编译时进行条件判断，使部分代码块在满足条件时被编译，否则完全忽略。

Cpp
constexpr bool condition = ...;
if constexpr (condition) {
    // 如果condition为真，则这段代码在编译时会被包含进来
} else {
    // 否则，这部分代码会被忽略
}
模板参数推导改进 对模板实参的类型推导进行了扩展，特别是对于类模板参数。

新类型 traits 包括 std::is_swappable 和 std::is_invocable 等新 trait 类型，用来检查类型是否可以安全地交换或调用。

std::optional 引入了官方的空值对象（nullable object）包装器，用于表示可能存在的值。

std::variant 作为升级版的 tagged union，允许存储一组类型中的任意一种，提供了安全的方式进行类型切换和访问。

std::any 能够存储任意类型的数据，提供了类似于类型擦除的安全容器。

std::string_view 不拥有所有权的字符串引用，提供了一种轻量级的方式来引用或传递字符串片段，不会复制字符串数据。

Inline Variables 允许在头文件中定义 inline 成员变量，解决了跨编译单元的链接问题。

Lambda 表达式的改进

可以捕获 *this 指针（隐式或显式），以便在闭包中访问当前对象。
更灵活的捕获列表语法。
对 auto 关键字的改进

自动类型推导更加强大，特别是在初始化列表方面。
Parallel Algorithms 尽管并非所有实现都完全支持，C++17 标准开始引入对并行算法的支持，如 std::sort 和 std::for_each 的并行版本。

C++14 新特性

C++11 新特性


# 会遇到信号与槽函数不响应

在C++中，特别是使用Qt框架时，信号和槽机制是一种强大的通信方式，允许对象之间在特定事件发生时互相通知和调用函数。然而，有时候你可能会遇到信号与槽函数不响应的问题，这可能是由以下几个原因造成的：

没有继承QObject并声明Q_OBJECT宏：
Qt的对象模型要求任何使用信号槽机制的类必须继承自QObject，并且在类定义中包含Q_OBJECT宏。这个宏是元对象编译器(MOC)处理的基础，用于生成必要的元数据，使得信号槽能够正常工作。

信号槽参数不匹配：
信号和槽的参数类型必须完全匹配，或者槽函数的参数可以比信号的参数少，但不能多，且顺序需要一致。类型不匹配会导致连接失败。

信号未声明为signals：
在类的声明中，信号必须放置在signals区域，否则Qt的元对象系统无法识别它们。

访问权限问题：
槽函数必须具有public、protected或private访问权限。如果槽函数是私有的且试图从外部连接，这可能导致问题。

元类型系统未注册自定义类型：
当使用自定义类型作为信号或槽的参数时，这些类型必须在使用前向Qt的元类型系统注册。否则，Qt无法正确解析这些类型，导致信号槽连接失败。

连接时机问题：
如果尝试在信号发出之前建立信号槽的连接，可能导致槽函数不被调用。确保在发送信号之前已经建立了有效的连接。

对象生命周期问题：
如果发射信号的对象或接收槽函数的对象在连接期间销毁，那么槽函数将不会被调用。确保相关对象的生命周期足够长。

事件循环被阻塞：
如果应用程序的事件循环（如QApplication的exec()）被阻塞，比如在槽函数中执行了长时间的运算或阻塞操作，那么后续的信号可能无法及时处理，导致界面无响应。

连接类型问题：
使用Qt::QueuedConnection时，如果参数类型没有注册到元对象系统，信号可能无法正确排队等待处理。

connect语法错误：
使用新版Qt的lambda表达式或functor作为槽时，容易出现语法错误，导致连接不成功。

检查以上方面通常能定位并解决信号槽不响应的问题。在开发过程中，使用Qt的调试工具和日志输出来辅助诊断这些问题也是很好的实践。


---

2.1.没有继承QObject，声明Q_OBJECT宏
因为信号槽机制是需要依赖Qt的反射机制的，如果不继承Object，编写信号和槽函数的时候就会直接报错的。

2.2.信号槽参数不匹配
信号槽的参数必须匹配。如果信号有参数，槽也必须具有相同数量和类型的参数。需要特别指出的是，在参数类型属于某命名空间时，要把命名空间写完整。

2.3.信号函数未声明为 signals

2.4.访问权限
定义信号signals不需要指定类型，默认就是public的。但是槽函数可以定义为pubic slots或 private slots或 protected slots。有时，私有信号和槽不能被外部对象连接。

2.5.注意connect的位置，信号在创建信号槽连接前使用，则无法触发槽函数
2.6.连接方式为Qt::QueuedConnection时参数类型没有注册
信号槽的参数是自定义的，这时需要用qRegisterMetaType注册一下这种类型。需要使用

include <QMetaType>        
qRegisterMetaType<此处为变量类型名称>("此处为变量类型名称")
来注册。 在Qt帮助手册中搜索qRegisterMetaType，有相关说明。 注意在调用connect时指定连接方式为Qt::DirectConnection（阻塞式触发），不会存在此问题。因为阻塞式触发，只需要将参数进行值传递，拷贝过去即可。而以Qt::QueuedConnection（消息队列式）连接的情况下，需要将变量转成通用数据类型QVariant存储，而用QVariant存储，必须要注册此类型。

2.7.对象生命周期
如果尝试连接的对象在连接时已经被销毁，那么连接就不会成功。确保对象在连接期间是有效的。

2.8.事件循环被阻塞导致信号未能发出
2.9.连接类型
使用适当的连接类型。Qt提供了几种不同的连接类型，包括Qt::DirectConnection、Qt::QueueConnection、Qt::AutoConnection等。

2.10.跨线程
如果信号和槽跨越不同的线程，则需要使用合适的连接类型来确保线程安全性。通常情况下，当信号和槽跨越不同的线程时，应该使用Qt::QueueConnection连接类型。

2.11.未定义的行为
在连接信号和槽时，确保在运行时信号和槽都是有效的。如果信号或槽未定义，连接操作可能会失败。

# 