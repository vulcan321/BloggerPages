第三部分、 c++11/c++14/c++17
1、C++11 中有哪些智能指针？shared_ptr 的引用计数是如何实现的？unique_ptr 的unique 是如何实现的？make_shared 和 make_unique 的作用？智能指针使用注意事项？
C++ 11 中的智能指针有：shared_ptr, unique_ptr 和 weak_ptr。
shared_ptr 的引用计数是存放在堆上的，多个 shared_ptr 的对象的引用计数都指向同一个堆地址。
unique_ptr 中拷贝构造函数和赋值操作符都声明为delete或private。
优先使用 make_shared 和 make_unique 的原因是为了避免内存泄露。参考 C++11 中的 Smart Pointer（shared_ptr/weak_ptr/unique_ptr） 总结
智能指针使用注意事项：
不使用相同的内置指针值初始化，或reset多个智能指针
不delete get()返回的指针
不使用get()初始化或reset另一个智能指针
get()返回的智能指针可能变成dangling pointer
如果智能指针管理的内存不是new出来的，需要提供删除器
拓展问题
shared_ptr 是否线程安全？
侵入式智能指针？
从源码理解智能指针（二）—— shared_ptr、weak_ptr
在这里插入图片描述

2、智能指针weak_ptr 能够破坏环型引用的原理（引用计数的原理）
weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。
引用计数原理
shared_ptr的实现是这样的: shared_ptr模板类有一个__shared_count类型的成员_M_refcount来处理引用计数的问题。__shared_count也是一个模板类，它的内部有一个指向Sp_counted_base_impl类型的指针_M_pi。所有引用同一个对象的shared_ptr都共用一个_M_pi指针。
当我们谈论shared_ptr的线程安全性时，我们在谈论什么

3、C++ 的闭包
闭包：与函数A调用函数B相比较，闭包中函数A调用函数B，可以不通过函数A给函数B传递函数参数，而使函数B可以访问函数A的上下文环境才可见(函数A可直接访问到)的变量；
c++11提供的闭包方式：lambda、function、bind

引用百度上对闭包的定义：闭包是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。

详见： c++11的闭包(lambda、function、bind)

4、lambda 表达式、怎么捕获外部变量
值捕获: 值捕获和参数传递中的值传递类似，被捕获的变量的值在Lambda表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响Lambda表达式中的值。
引用捕获: 使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符&。
隐式捕获: 还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获
混合方式捕获: 即同时使用显式捕获和隐式捕获。混合捕获时，捕获列表中的第一个元素必须是 = 或 &，此符号指定了默认捕获的方式是值捕获或引用捕获。
C++11捕获外部变量总结

捕获形式	说明
[]	不捕获任何外部变量
[变量名, …]	默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&说明符）
[this]	以值的形式捕获this指针
[=]	以值的形式捕获所有外部变量
[&]	以引用形式捕获所有外部变量
[=, &x]	变量x以引用形式捕获，其余变量以传值形式捕获
[&, x]	变量x以值的形式捕获，其余变量以引用形式捕获
5、C++ 的垃圾回收机制
很多语言都有对内存自动管理，即所谓的垃圾回收机制。所谓垃圾，指的是那些不再使用或者没有任何指针指向的内存空间，而“回收”则指的是将这些“垃圾”收集起来以便再次利用。C++采用 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。来实现自动释放分配的内存。
C++之智能指针（C++的垃圾回收机制）

6、vector的clear()的时间复杂度是多少？
C++标准明确指出不管是序列容器（⽐如vector）还是关联容器（⽐如unordered_map)其
clear()成员函数都是线性时间复杂度O(n)的。因为只要执⾏了clear()就需要对其存储的元素调⽤析构函数 ，这个析构操作显然是逐个析构的。因⽽时间复杂度是O(n)。
当然在实践中，也有个例。⽐如当vector存储基本数据类型或POD类型（⽐如基本数据类型构成的struct）的时候，由于其元素类型没有析构函数（也不需要析构函数），加之vector内部连续存储的特性，编译器的实现是可以在常量时间完成clear()的。
仅限于vector存储基本数据类型和POD类型的时候，编译器可能有此优化。如果vector存储的
是其他类型的对象，或者是其他容器（⽐如list、map、unordered_map）都是没办法做这个优化的！
详见： C++和STL中有哪些副作用或者稍不注意会产生性能开销的地方？

7、C++11为什么引入enum class？
C++98 的 enum 是“非域化的”；而 C++11 的 enum class 是“域化的”，限制了枚举成员只在域内可见
enum class 的缺省潜在类型 (underlying type) 是 int 型，而 enum 没有缺省潜在类型
enum class 一般总是前置声明，而 enum 只有在指定了潜在类型时才可以是前置声明
详见： C++11 之 enum class

8、std::thread使用lambda做回调，有没有什么注意事项？
使用到外部引用要小心谨慎，避免悬空引用。
若需要用到的外部局部变量，需以值传递的方式捕获而非引用捕获（若是外部指针变量则需深拷贝）。
谨慎使用或者不用外部指针。
如果你用值捕获了个指针，你在lambda创建的闭包中持有这个指针的拷贝，但你不能阻止lambda外面的代码删除指针指向的内容，从而导致你拷贝的指针空悬。
注意引用捕获陷阱：引用捕获[&]不要使用外部局部变量。
注意this陷阱：lambda里避免有全局变量或静态变量或者比当前类生命周期更长的变量。Effective Modern C++ 条款31 对于lambda表达式，避免使用默认捕获模式。
避免使用默认捕获模式(（即“[=]”或“[&]”,它可能导致你看不出悬空引用问题)。
默认值捕获就意外地捕获了this指针，而不是你以为的外部变量。
例子参考： c++的lambda使用注意事项,可能导致的崩溃问题分析

9、C++11的thread_local有没有使用过？
有且只有thread_local关键字修饰的变量具有线程周期(thread duration)，这些变量(或者说对象）在线程开始的时候被生成(allocated)，在线程结束的时候被销毁(deallocated)。并且每 一个线程都拥有一个独立的变量实例(Each thread has its own instance of the object)。thread_local 可以和static 与 extern关键字联合使用，这将影响变量的链接属性(to adjust linkage)。
那么，哪些变量可以被声明为thread_local？以下3类都是ok的

命名空间下的全局变量
类的static成员变量
本地变量
详见： C++11中thread_local的使用

10、谈一谈你对zero overhead（零开销原则）的理解
不需要为没有使用到的语言特性付出代价。
使用某种语言特性，不会带来运行时的代价。
详见： 跟我学c++中级篇——zero overhead abstraction

11、了解移动语义和完美转发吗？
移动语义：可以理解为转移所有权，拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，通过C++11新增的移动语义可以省去很多拷贝负担，如何利用移动语义，主要通过移动构造函数。

完美转发：指可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参。转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数也是右值。
参考： C++11之右值引用：移动语义和完美转发(带你了解移动构造函数、纯右值、将亡值、右值引用、std::move、forward等新概念)

12、了解列表初始化吗？
列表初始化：可以直接在变量名后面加上初始化列表来进行对象的初始化。
参考： C++11之初始化列表

