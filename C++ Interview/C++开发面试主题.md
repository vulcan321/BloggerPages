C++开发面试通常涵盖多个主题，从基础语法和概念到更高级的主题，如面向对象编程、设计模式、STL库等。以下是一些常见的C++面试题，用于评估应聘者的知识水平和编程能力：

1. 基础语法与概念

解释C++中的指针和引用的区别。
描述C++中的堆和栈的区别，并说明如何在它们之间分配内存。
解释C++中的多态性，包括虚函数和纯虚函数的作用。
阐述C++中的异常处理机制。
2. 面向对象编程

解释面向对象编程的三大特性：封装、继承和多态。
描述一个类的构造函数和析构函数的作用。
什么时候使用拷贝构造函数和赋值运算符？它们之间有什么区别？
解释什么是虚析构函数，为什么需要它？
3. STL库

描述STL库中的常见容器，如vector、list、map等，并解释它们的特点和适用场景。
你如何理解STL中的迭代器？请给出一个使用迭代器的例子。
描述STL中的算法，如sort、find等，并解释如何与容器结合使用。
4. 设计模式

解释什么是设计模式，并列举你熟悉的设计模式（如单例模式、工厂模式等）。
描述单例模式的实现原理及其优缺点。
在什么情况下你会使用工厂模式？请给出一个使用工厂模式的例子。
5. 内存管理

描述C++中的内存泄漏是什么，如何避免它？
解释智能指针（如shared_ptr、unique_ptr）的作用和使用场景。
你如何理解RAII（Resource Acquisition Is Initialization）技术？
6. 模板与泛型编程

解释C++中的模板和泛型编程的概念。
描述函数模板和类模板的区别和用法。
7. 多线程与并发

解释C++11中的线程库及其用法。
描述互斥锁和条件变量的作用和使用场景。
你如何理解死锁和活锁？如何避免它们？
8. 代码优化与调试

描述你通常如何进行代码优化？有哪些常见的优化策略？
你使用过哪些调试工具？如何定位和解决程序中的bug？
这些问题只是C++面试中的一部分，实际面试中可能还会根据应聘者的经验和技能水平进行更深入的探讨。因此，建议应聘者在准备面试时，除了复习基础知识外，还要关注最新的C++特性和技术动态，以展示自己的专业素养和学习能力。

C++开发的高级主题相当广泛且深入，涵盖了多个重要领域。以下是一些C++开发中的高级主题：

模板元编程（Template Metaprogramming）：
模板是C++提供的一种强大工具，用于实现代码重用、类型安全和效率提升。
模板元编程利用模板在编译时进行复杂计算，生成高效的代码。
涉及的技术包括模板特化、可变参数模板、标签调度等。
智能指针与现代内存管理：
智能指针如std::unique_ptr、std::shared_ptr和std::weak_ptr有助于自动管理动态分配的内存，防止内存泄漏。
深入理解RAII（Resource Acquisition Is Initialization）原则，在对象生命周期内自动管理资源。
STL（Standard Template Library）的高级用法：
除了基本的容器和算法外，STL还提供了迭代器、适配器、函数对象等高级功能。
熟练使用STL的高级特性，可以写出高效且易于维护的代码。

C++11及以后版本的新特性：
C++11引入了lambda表达式、右值引用、移动语义、范围for循环等大量新特性。
后续的C++版本（如C++14、C++17、C++20等）继续扩展了C++的功能和性能。
多线程与并发编程：
利用C++11及以后版本的线程库进行多线程编程。
理解并应用互斥锁、条件变量、原子操作等同步机制。
学习并发设计模式，以编写高效且安全的并发代码。
泛型编程与类型萃取：
深入理解泛型编程的概念，利用类型萃取技术实现灵活的代码结构。
设计模式：
设计模式是解决常见设计问题的最佳实践。
深入学习并掌握各种设计模式，如单例模式、工厂模式、观察者模式等，并能在实际项目中灵活应用。
性能优化与调试：
学习并掌握性能分析工具，如gprof、Valgrind等，对代码进行性能分析和优化。
学习调试技巧，如使用GDB等调试器进行代码调试和故障排查。
C++网络编程：
学习如何使用C++进行网络编程，包括套接字编程、异步IO、多线程网络服务器等。
C++与硬件交互：
深入了解C++与硬件的交互方式，如使用C++进行嵌入式系统开发、图形界面开发等。
这些高级主题通常需要深入理解C++语言的核心概念，并具备丰富的编程经验。通过学习和实践这些主题，C++开发人员可以进一步提升自己的编程技能和项目能力。

腾讯公司在招聘C++开发人员时，可能会在笔试环节中包含一些与C++编程和算法相关的题目。虽然具体的题目可能会因招聘职位和岗位需求的不同而有所差异，但以下是一些常见的C++ LeetCode题目类型，这些题目可能会出现在腾讯的笔试中：

数组与链表操作：
反转链表（Reverse Linked List）
合并两个有序链表（Merge Two Sorted Lists）
移除链表中的节点（Remove Nth Node From End of List）
查找链表中环的起点（Detect Cycle in a Linked List）
栈与队列的应用：
用栈实现队列（Implement Queue using Stacks）
用队列实现栈（Implement Stack using Queues）
设计最小栈（Min Stack）
树与图的操作：
二叉树的遍历（Inorder, Preorder, Postorder）
构造二叉搜索树（Construct Binary Search Tree from Preorder and Inorder Traversal）
二叉树的最近公共祖先（Lowest Common Ancestor of a Binary Tree）
图的深度优先搜索（DFS）和广度优先搜索（BFS）
字符串处理：
最长回文子串（Longest Palindromic Substring）
字符串反转（Reverse String）
实现 strStr() 函数（Implement strStr()）
动态规划与递归：
爬楼梯（Climbing Stairs）
打家劫舍（House Robber）
背包问题（Knapsack Problem）
排序与查找：
快速排序（Quick Sort）
归并排序（Merge Sort）
二分查找（Binary Search）
位运算：
单数出现的次数（Single Number）
找出数组中消失的数字（Find the Missing Number）
数据结构与算法的综合应用：
LRU缓存机制（LRU Cache）
设计哈希集合（Design HashSet）
设计哈希映射（Design HashMap）

# std::deque（双端队列）

std::deque（双端队列）是一种索引序列容器，它允许在其开头和结尾快速地插入和删除元素。此外，无论在双端队列的哪一端进行插入和删除操作，指向其余元素的指针或引用都不会失效。

与std::vector不同，双端队列中的元素并非连续存储：典型的实现会使用一系列单独分配的固定大小数组，并附加额外的管理信息，这意味着对双端队列的索引访问必须执行两次指针解引用，而向量的索引访问仅需一次。

双端队列的存储空间会根据需要自动扩展和收缩。与std::vector的扩容相比，双端队列的扩容成本更低，因为它不需要将现有元素复制到新的内存位置。另一方面，双端队列通常有较大的最小内存开销；即使双端队列只持有单个元素，也必须为其内部数组分配完整的存储空间（例如，在64位libstdc++上约为元素大小的8倍；在64位libc++上则是元素大小的16倍或4096字节，取两者中较大的一个）。

# Qt

## Qt的多线程环境下，信号与槽的实现机制

### 线程归属

每个QObject实例都属于一个线程，通常是创建它的线程。信号和槽函数的执行也遵循所属线程的原则。
当一个信号在某个线程中被发射时，如果连接的槽函数位于不同的线程，Qt会确保槽函数在正确的线程中执行。

### 连接类型

Qt提供了几种信号与槽的连接类型，通过connect函数的最后一个参数指定，这影响了信号如何调用槽函数：

* Qt::DirectConnection：槽函数直接在发射信号的线程中被调用。如果槽函数和信号不在同一个线程，可能会引发线程安全问题。  
* Qt::QueuedConnection：这是多线程中最常用的连接类型。信号发射后，槽函数的调用被封装成一个事件并放入接收者线程的事件队列中，等待该线程的事件循环处理。这样确保了槽函数在发射信号的线程之外的安全执行。 
* Qt::BlockingQueuedConnection：类似于Qt::QueuedConnection，但是发射信号的线程会阻塞，直到槽函数执行完毕。  
* Qt::AutoConnection：Qt会根据信号发送者和接收者是否在同一线程自动选择Qt::DirectConnection或Qt::QueuedConnection。  

### 事件循环

每个Qt线程都有自己的事件循环，用于处理事件（包括信号槽调用的事件）。只有当线程启动了一个事件循环，信号槽机制才能跨线程工作。

### 线程间通信

为了在不同线程间安全地使用信号槽，通常会将槽函数的执行委托给对象所在的线程，尤其是对于UI更新。这意味着，如果需要在主线程中更新UI，应确保相关的槽函数在主线程中执行。

### 使用moveToThread

可以通过moveToThread函数改变一个QObject及其子对象的线程归属。但需要注意，已连接的信号槽关系不会自动调整，因此在移动对象后，可能需要重新建立连接以符合新的线程环境。

### 线程安全

虽然信号槽机制本身是线程安全的，但槽函数内部的代码需要自行保证线程安全，尤其是在访问共享资源时。
综上所述，Qt通过灵活的连接类型和事件循环机制，实现了跨线程的信号槽通信，保证了在多线程环境下的高效与安全交互。

## Qt槽函数不响应的原因

### 1.没有继承QObject，声明Q_OBJECT宏

因为信号槽机制是需要依赖Qt的反射机制的，如果不继承Object，编写信号和槽函数的时候就会直接报错的。

### 2.信号槽参数不匹配

信号槽的参数必须匹配。如果信号有参数，槽也必须具有相同数量和类型的参数。需要特别指出的是，在参数类型属于某命名空间时，要把命名空间写完整。

### 3.信号函数未声明为 signals

### 4.访问权限

定义信号signals不需要指定类型，默认就是public的。但是槽函数可以定义为pubic slots或 private slots或 protected slots。
私有信号和槽不能被外部对象连接。

### 5.注意connect的位置，信号在创建信号槽连接前使用，则无法触发槽函数

### 6.连接方式为Qt::QueuedConnection时参数类型没有注册

信号槽的参数是自定义的，这时需要用qRegisterMetaType注册一下这种类型。

```cpp
#include <QMetaType>   
qRegisterMetaType<此处为变量类型名称>("此处为变量类型名称")
```

注意在调用connect时指定连接方式为Qt::DirectConnection（阻塞式触发），不会存在此问题。
因为阻塞式触发，只需要将参数进行值传递，拷贝过去即可。
以Qt::QueuedConnection（消息队列式）连接的情况下，需要将变量转成通用数据类型QVariant存储，而用QVariant存储，必须要注册此类型。

### 7.对象生命周期

如果尝试连接的对象在连接时已经被销毁，那么连接就不会成功。确保对象在连接期间是有效的。

### 8.事件循环被阻塞导致信号未能发出

### 9.连接类型

使用适当的连接类型。Qt提供了几种不同的连接类型，包括Qt::DirectConnection、Qt::QueueConnection、Qt::AutoConnection等。

### 10.跨线程

如果信号和槽跨越不同的线程，则需要使用合适的连接类型来确保线程安全性。通常情况下，当信号和槽跨越不同的线程时，应该使用Qt::QueueConnection连接类型。

### 11.未定义的行为

在连接信号和槽时，确保在运行时信号和槽都是有效的。如果信号或槽未定义，连接操作可能会失败。