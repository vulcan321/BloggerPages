概念：

LRU（least recently used)是将近期最不会访问的数据给淘汰掉，其实LRU是认为最近被使用过的数据，那么将来被访问的概率也多，最近没有被访问，那么将来被访问的概率也比较低“，其实这个并不是正确的，但是因为LRU算法简单，存储空间没有被浪费，所以还是用的比较广泛的。


LRU原理：

LRU一般采用[链表](https://so.csdn.net/so/search?q=%E9%93%BE%E8%A1%A8&spm=1001.2101.3001.7020)的放缓死实现，便于快速移动数据位置。网上找了一个图，感觉画的很赞，所以就粘过来了，为了说明问题~~~~~感谢这个图的作者！！！！

  

  

  

![](https://img-blog.csdn.net/20170901161029050?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhb19NcnNfbGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  

LRU的实现有两种方式：缓存命中后，是否要这个数据缓存项到LRU队列的最前端。

首先这个图说明的是LRU的一种实现方式，那就是在缓存访问命中后，要将这个数据缓存项到达LRU队列的最前端。第五步，将E插入缓存池后，这个缓存池已经满了，所以第六步插入F后，要考虑把近期没有访问的数据，也就是A给淘汰掉了（可怜的A啊。。。。）第七步，C被访问，从时间点来说，C最近被访问过了，所以移动到了链表的头部（暂时没有被淘汰）；第八步，将G存入缓存后，G位于链表头部，那么B只能被淘汰了。。。。

因为链表的插入和删除时间复杂度都为O（1），所以用链表不用数组