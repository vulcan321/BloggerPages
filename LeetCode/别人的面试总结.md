**面试结论：**

基本上每家公司都会有三轮及以上技术面试，所有的公司都会考察算法题，每一轮面试基本都会做1-2道算法题，每家公司通过所有面试的话，需要做3-5道题左右。 另外，我跳槽的同时，组内近半年内也有其他三位同事跳槽，他们除了参加我提到的公司外（参加不同的组），也参加了 百度，B站，小红书，360，拼多多等公司的社招。大家每次面试完，都会复盘算法题，以及对应的项目问题，我们四个人近两个月，共参加了近100场技术面试，每个人至少拿到3-4家offerr。所有面试完了以后，我们得到一些结论，简单来说，结论如下：

1）**每一轮面试，只要你把算法题写出来，就能通过本轮面试**（说的有点绝对了，不过我们统计了，有高达95%的概率）。

2）**每一轮面试，如果算法题写不出来，基本这场面试就会不通过**（90%概率不通过）。

3）**每一轮面试，如果只能写出1道题（考查了2道题），或者给出1道题的思路，非最优的，这种大约以50%机率通过面试**（看运气了）。

（PS：可能我们在准备项目时，几个人已经反反复复把项目所遇到的难点都搞清楚了，所以基本上项目相关的问题，我们都能corver住）

现实就是这样，可能算法题和工作无关，工作中也无法用到，甚至说和工作能力的相关性比较小，但是这就是目前求职人员比较多，考察算法题是快速筛选某个人是否合适的一个简单的方法。 咱们这里不讨论这种方式的合理性，只看现象，如果你想拿到一个offer，你至少在整个求职过程中估计得完美的写出3道题。

下面的篇幅，只写干货，不写废话，写下面试时考察算法题难度的和刷题经历：

**1\. 面试难度**

这几家公司的面试的算法题大部分对应的是leetcode的medium题，小部分是easy题，极少数是hard，就公司而言如下（这个因人而异，我们几个的结论是这么来的）：

头条 > 快手，腾讯，百度，美团，拼多多 > 阿里，知乎，B站 > 天眼查，360，小红书

即头条的面试难度会独一档，不过也不是特别难，头条的面试体验就是，它往往会考察一道leetcode medium的变形题，这个就要求你平常刷题时不仅会做，还要会举一反三。其他公司绝大部分都是medium+easy的组合题。

**2\. 我的刷题经历**

这里假设你有3个月以上的准备时间，且假设你对基本的[数据结构](https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)都比较熟悉，那么你可以按照下面的顺序刷题：

0). 首先在leetcode网站上注册一个账号\[leetcode\]([https://leetcode-cn.com/problemset/all/](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problemset/all/))

1).按照labuladong小抄走一遍（可以看公众号，也可以看他的书籍，里面讲解的一些模板套路还是很不错的，网上百度下就能找到），如果遇到的leetcode题目，建议直接在leetcode网站上写。 （1个月）

2).然后按照101那个书（LeetCode 101 - A LeetCode Grinding Guide (C++ Version).pdf）过一遍（思路+题），同样，如果遇到的leetcode题目，建议直接在leetcode网站上写。（1个月）

3).然后leetcode的TOP热门高频145题，刷一遍，网址\[link\]([https://leetcode-cn.com/problem\-list/2ckc81c/](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problem-list/2ckc81c/)) ，遇到之前刷过的，可以再看一遍解法。（2周）

4).牛客网上剑指 offer题目刷一遍，\[link\]([https://www.nowcoder.com/ta/coding-interviews](https://link.zhihu.com/?target=https%3A//www.nowcoder.com/ta/coding-interviews))，上述刷完以后，这个刷起来就比较轻松。（3天）

5).把做过的题leetcode题，从头到尾捋一遍。（只写思路，不写题，遇到还是没思路的，再写一遍）。1周

以上题目在leetcode上，大约总共做了323题，这个不包括本地写的几十道模板题目。

**3\. 刷题感悟：**

看完[labuladong](https://www.zhihu.com/search?q=labuladong&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)的刷题思路后，绝大部分题（刷过的）都能想到思路，有一半能bug free写出来。

刷完101后，写代码能力得到进一步提升，基本做到有思路的（前提是思路是对的），绝大部分能bug free的写出来，比较101和labuladong，我感觉101很难刷，题多很多（包括所有的课后题）。

后面再写leetcode的140题时，能做到有思路就能写出来，没思路就写不出来，不过实际刷的过程中，凡是没做过的题，还是不会写，我理解leetcode的技巧性还是很高，于是凡是遇到不会的题，思考几分钟就看答案。

上面那个搞完以后，我开始想写剑指 offer题，由于校招之前找工作时刷过，再加上这次已经刷了不少题，而且[剑指 offer](https://www.zhihu.com/search?q=%E5%89%91%E6%8C%87%20offer&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)上的题相对比较简单，所以我直接在[牛客](https://www.zhihu.com/search?q=%E7%89%9B%E5%AE%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)上花了大约3天，刷完了所有的（七八十道题），注意这些刷题并不是一天全部时间，每天只抽出一半时间，毕竟还要工作以及其他杂七杂八的事情。

刷完剑指 offer后，感觉自己对于常见的高频算法题基本都已经掌握，剩下的就是重新复习下，以应付那种偶尔来一个很偏的题，自己做过，但是忘了思路的，所以又花了一周把之前做过的题从头到尾过一遍。

  

4\. **如果只有很短的时间，该做哪些题？**

假设你**只有一周**的准备时间，就想做12道题，那就做下面12道题吧（注意下面的题我没有放链接，直接百度搜就能搜到，这些题太有名了，可以说记忆深刻）：

1)最长有效括号\[link\]([https://leetcode-cn.com/problems/longest-valid-parentheses/submissions/](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/longest-valid-parentheses/submissions/) ) ：利用栈，(入栈，)出栈，然后判断栈是否为空，并统计最大长度；注意栈存储下标，开始预先存储一个-1. 或者，利用两个计数器，left和right分别统计左括号和右括号的个数

2)接雨水：就是找左边最大值（大于该元素）和右边最大值，两个取较小那个，再减去当前高度。 双指针。

3)通配符匹配：[动态规划](https://www.zhihu.com/search?q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)

4)组合的总和II：先判断sum>target，再判断sum=target，更新res，然后判断index > n，之后for，for里判断i > index && num\[i\] == num\[ i - 1\] continue；用来去重，之后[push\_back](https://www.zhihu.com/search?q=push_back&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)() 回溯 pop\_back()

5)缺失的第一个正数：第一次for，如果数组<0，则都修改成n+1；第二次for，如果数组元素<=n，则把以该值-1为下标的数组修改成负的（-abs(...))，第三次for，从头到尾找第一个为负的元素。

6)搜索[旋转排序数组](https://www.zhihu.com/search?q=%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)：确定有序的那一段，然后利用target是否在有序的这一段来减半查找。如果数组里有重复的元素（nums\[left\] == nums\[mid\])，则left++。搜索[旋转数组最小值](https://www.zhihu.com/search?q=%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)，处理也是如此，注意有重复元素时，需要判断nums\[left\]==nums\[mid\]

7)删除链表中的重复元素：就定义一个[dummy节点](https://www.zhihu.com/search?q=dummy%E8%8A%82%E7%82%B9&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)，判断pre->next->val == p->val，注意p是落后pre两个节点的。pre就是记录前面没有重复元素的第一个节点。

8)不同的二叉搜索树II：这个就是想着怎么生成左子树，右子树。然后组合成新的树。link

9)判断两个字符串是否构成另一个字符串：[二维动态规划](https://www.zhihu.com/search?q=%E4%BA%8C%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)

10)验证二叉搜索树：就是需要辅助函数传入最小节点，最大节点。

11)二叉树的[非递归遍历](https://www.zhihu.com/search?q=%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)：

前序遍历：

使用栈，先把根存到栈里，然后while(!st.empty())，出栈，存结果到res里，然后如果右节点非空，把右节点加到栈里，左节点非空，把左节点加到栈里。

[中序遍历](https://www.zhihu.com/search?q=%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)：

把根节点加到栈里，然后循环遍历左节点，加到栈里。弹出元素，加到res里，如果该元素有右节点，T=右节点。

[后序遍历](https://www.zhihu.com/search?q=%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1980693568%7D)：

两个栈模拟，后序遍历是：左->右->根。 注意第二个栈，入栈是：根->右->左。 第一个栈：就弹出元素，加到第二个栈里，然后把非空的左孩子，右孩子加到栈。

12)字符串转化整数atoi

  

如果你有两个月的准备时间，那就刷下面的113道题吧：

[还我漂漂拳：高频算法题——每次跳槽刷一遍](https://zhuanlan.zhihu.com/p/386929820)