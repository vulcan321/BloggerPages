# 二进制枚举--最通俗易懂的讲解



> **二进制：**是计算技术中广泛采用的一种[数制](https://baike.baidu.com/item/%E6%95%B0%E5%88%B6/217113)。[二进制数](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0)据是用0和1两个[数码](https://baike.baidu.com/item/%E6%95%B0%E7%A0%81/552177)来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”
> 
> **子集：**是一个数学概念：如果[集合](https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020)_A_的**任意一个元素**都是集合_B_的元素，那么集合_A_称为集合_B_的**子集**。
> 
> **含有N个元素的集合的一切子集的个数为 2^n。简单证明一下：**
> 
> -   含有0个元素的子集有C(N,0)个，
> -   含有1个元素的子集有C(N,1)个，
> -   含有2个元素的子集有C(N,2)个，
> -   .........
> -   含有N个元素的子集有C(N,N)个
> 
> **由二项式系数的性质可得：** C(N,0)+C(N,1)+C(N,2)+...+C(N,N)=2^n。

我们就是利用了[二进制](https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020)的特性 ，比如说有5个木棍的长度：4， 8， 2， 6， 7。我们就可以用**0**和**1**代表**选**和**不选**。

如果选出长度为4、2、6的木棍，则如下表：

<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><th style="width:128px;">&nbsp;</th><td style="width:174px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4</td><td style="width:168px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8</td><td style="width:154px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2</td><td style="width:112px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6</td><td style="width:110px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7</td></tr><tr><th style="width:128px;">二进制</th><td style="width:174px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1&nbsp;</td><td style="width:168px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0</td><td style="width:154px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</td><td style="width:112px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</td><td style="width:110px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0</td></tr><tr><th style="width:128px;">木棍的状态</th><td style="width:174px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;选</td><td style="width:168px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;不选</td><td style="width:154px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 选</td><td style="width:112px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 选</td><td style="width:110px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不选</td></tr></tbody></table>


上面说有5个木棍如果全选的话就是11111对应的十进制数就是31，\[0,2^{n}-1\] 这个区间上每一个整数代表一个集合一共  **2^n**个集合，上表就是数字22（二进制：10110）所代表的集合：4、2、6。

所以我们遍历每一个集合：

```cpp
for(int i = 0; i < (1 << n); i++)
```

设s = 13（二进制为1101）代表我们选0 2 3位置上的数值；

那么我们如何找到每个位置上的数值呢？

我们遍历的是二进制的十进制表示（比如13），我们当然可以转化为二进制再[枚举](https://so.csdn.net/so/search?q=%E6%9E%9A%E4%B8%BE&spm=1001.2101.3001.7020)每一位，但是，这很麻烦；

一个很巧妙的方式就是利用位运算。

> 1<<0=1(0);
> 
> 1<<1=2(10);
> 
> 1<<2=4(100);
> 
> 1<<3=8(1000);
> 
> 1<<4=16(10000);
> 
> ...
> 
> 1<<7=128(10000000);
> 
> ...

看出来了吧！我们只需要将13&(1<<i)我们便可以得到每一位是不是1 （1<< i 除了那一位，剩余的都是0，所以我们就可以得到那一位是不是1）

补充一波位运算的知识吧：

> ### 按位与运算符（&）

参加运算的两个数据，按二进制位进行“与”运算。

运算规则：0&0=0;  0&1=0;   1&0=0;    1&1=1;

      即：两位同时为“1”，结果才为“1”，否则为0

例如：3&5  即 0000 0011& 0000 0101 = 00000001  因此，3&5的值得1。

> ## 左移运算（<<）

a << b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，那么100 << 2 = 400。可以看出，a << b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2(这样做要求保证高位的1不被移出)。  
通常认为a << 1比a \* 2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作请尽量用左移一位来代替。

因此，我们便有了：

```cpp
for(int i = 0; i < (1 << n); i++)
{
    for(int j = 0; j < n; j++)
    {
        if(i & (1 << j))
        {
            printf(" %d ",a[j]);
        }
    }
}

```

那么完整的代码就是： 

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin >> n;
    //从0～2^n-1个状态
    for(int i = 0; i < (1<<n); i++) 
    {
        //遍历二进制的每一位
        for(int j = 0; j < n; j++) 
        {
            //判断二进制第j位是否存在
            if(i & (1 << j))
            {
                //如果存在输出第j个元素
                printf("%d ",j);
            }
        }
        printf("\n");
    }
    return 0;
}
```

例题1：ALGO-115\_蓝桥杯\_算法训练\_和为T[点击这里](https://blog.csdn.net/sugarbliss/article/details/81101493)

例题2：HDU5616--Jam's balance[点击这里](https://blog.csdn.net/sugarbliss/article/details/81101591)
```
0, 
1, 
0, 1, 
2, 
0, 2, 
1, 2, 
0, 1, 2, 
3, 
0, 3, 
1, 3, 
0, 1, 3, 
2, 3, 
0, 2, 3, 
1, 2, 3, 
0, 1, 2, 3, 
4, 
0, 4, 
1, 4, 
0, 1, 4, 
2, 4, 
0, 2, 4, 
1, 2, 4, 
0, 1, 2, 4, 
3, 4, 
0, 3, 4, 
1, 3, 4, 
0, 1, 3, 4, 
2, 3, 4, 
0, 2, 3, 4, 
1, 2, 3, 4, 
0, 1, 2, 3, 4, 
5, 
0, 5, 
1, 5, 
0, 1, 5, 
2, 5, 
0, 2, 5, 
1, 2, 5, 
0, 1, 2, 5, 
3, 5, 
0, 3, 5, 
1, 3, 5, 
0, 1, 3, 5, 
2, 3, 5, 
0, 2, 3, 5, 
1, 2, 3, 5, 
0, 1, 2, 3, 5, 
4, 5, 
0, 4, 5, 
1, 4, 5, 
0, 1, 4, 5, 
2, 4, 5, 
0, 2, 4, 5, 
1, 2, 4, 5, 
0, 1, 2, 4, 5, 
3, 4, 5, 
0, 3, 4, 5, 
1, 3, 4, 5, 
0, 1, 3, 4, 5, 
2, 3, 4, 5, 
0, 2, 3, 4, 5, 
1, 2, 3, 4, 5, 
0, 1, 2, 3, 4, 5, 
6, 
0, 6, 
1, 6, 
0, 1, 6, 
2, 6, 
0, 2, 6, 
1, 2, 6, 
0, 1, 2, 6, 
3, 6, 
0, 3, 6, 
1, 3, 6, 
0, 1, 3, 6, 
2, 3, 6, 
0, 2, 3, 6, 
1, 2, 3, 6, 
0, 1, 2, 3, 6, 
4, 6, 
0, 4, 6, 
1, 4, 6, 
0, 1, 4, 6, 
2, 4, 6, 
0, 2, 4, 6, 
1, 2, 4, 6, 
0, 1, 2, 4, 6, 
3, 4, 6, 
0, 3, 4, 6, 
1, 3, 4, 6, 
0, 1, 3, 4, 6, 
2, 3, 4, 6, 
0, 2, 3, 4, 6, 
1, 2, 3, 4, 6, 
0, 1, 2, 3, 4, 6, 
5, 6, 
0, 5, 6, 
1, 5, 6, 
0, 1, 5, 6, 
2, 5, 6, 
0, 2, 5, 6, 
1, 2, 5, 6, 
0, 1, 2, 5, 6, 
3, 5, 6, 
0, 3, 5, 6, 
1, 3, 5, 6, 
0, 1, 3, 5, 6, 
2, 3, 5, 6, 
0, 2, 3, 5, 6, 
1, 2, 3, 5, 6, 
0, 1, 2, 3, 5, 6, 
4, 5, 6, 
0, 4, 5, 6, 
1, 4, 5, 6, 
0, 1, 4, 5, 6, 
2, 4, 5, 6, 
0, 2, 4, 5, 6, 
1, 2, 4, 5, 6, 
0, 1, 2, 4, 5, 6, 
3, 4, 5, 6, 
0, 3, 4, 5, 6, 
1, 3, 4, 5, 6, 
0, 1, 3, 4, 5, 6, 
2, 3, 4, 5, 6, 
0, 2, 3, 4, 5, 6, 
1, 2, 3, 4, 5, 6, 
0, 1, 2, 3, 4, 5, 6, 
7, 
0, 7, 
1, 7, 
0, 1, 7, 
2, 7, 
0, 2, 7, 
1, 2, 7, 
0, 1, 2, 7, 
3, 7, 
0, 3, 7, 
1, 3, 7, 
0, 1, 3, 7, 
2, 3, 7, 
0, 2, 3, 7, 
1, 2, 3, 7, 
0, 1, 2, 3, 7, 
4, 7, 
0, 4, 7, 
1, 4, 7, 
0, 1, 4, 7, 
2, 4, 7, 
0, 2, 4, 7, 
1, 2, 4, 7, 
0, 1, 2, 4, 7, 
3, 4, 7, 
0, 3, 4, 7, 
1, 3, 4, 7, 
0, 1, 3, 4, 7, 
2, 3, 4, 7, 
0, 2, 3, 4, 7, 
1, 2, 3, 4, 7, 
0, 1, 2, 3, 4, 7, 
5, 7, 
0, 5, 7, 
1, 5, 7, 
0, 1, 5, 7, 
2, 5, 7, 
0, 2, 5, 7, 
1, 2, 5, 7, 
0, 1, 2, 5, 7, 
3, 5, 7, 
0, 3, 5, 7, 
1, 3, 5, 7, 
0, 1, 3, 5, 7, 
2, 3, 5, 7, 
0, 2, 3, 5, 7, 
1, 2, 3, 5, 7, 
0, 1, 2, 3, 5, 7, 
4, 5, 7, 
0, 4, 5, 7, 
1, 4, 5, 7, 
0, 1, 4, 5, 7, 
2, 4, 5, 7, 
0, 2, 4, 5, 7, 
1, 2, 4, 5, 7, 
0, 1, 2, 4, 5, 7, 
3, 4, 5, 7, 
0, 3, 4, 5, 7, 
1, 3, 4, 5, 7, 
0, 1, 3, 4, 5, 7, 
2, 3, 4, 5, 7, 
0, 2, 3, 4, 5, 7, 
1, 2, 3, 4, 5, 7, 
0, 1, 2, 3, 4, 5, 7, 
6, 7, 
0, 6, 7, 
1, 6, 7, 
0, 1, 6, 7, 
2, 6, 7, 
0, 2, 6, 7, 
1, 2, 6, 7, 
0, 1, 2, 6, 7, 
3, 6, 7, 
0, 3, 6, 7, 
1, 3, 6, 7, 
0, 1, 3, 6, 7, 
2, 3, 6, 7, 
0, 2, 3, 6, 7, 
1, 2, 3, 6, 7, 
0, 1, 2, 3, 6, 7, 
4, 6, 7, 
0, 4, 6, 7, 
1, 4, 6, 7, 
0, 1, 4, 6, 7, 
2, 4, 6, 7, 
0, 2, 4, 6, 7, 
1, 2, 4, 6, 7, 
0, 1, 2, 4, 6, 7, 
3, 4, 6, 7, 
0, 3, 4, 6, 7, 
1, 3, 4, 6, 7, 
0, 1, 3, 4, 6, 7, 
2, 3, 4, 6, 7, 
0, 2, 3, 4, 6, 7, 
1, 2, 3, 4, 6, 7, 
0, 1, 2, 3, 4, 6, 7, 
5, 6, 7, 
0, 5, 6, 7, 
1, 5, 6, 7, 
0, 1, 5, 6, 7, 
2, 5, 6, 7, 
0, 2, 5, 6, 7, 
1, 2, 5, 6, 7, 
0, 1, 2, 5, 6, 7, 
3, 5, 6, 7, 
0, 3, 5, 6, 7, 
1, 3, 5, 6, 7, 
0, 1, 3, 5, 6, 7, 
2, 3, 5, 6, 7, 
0, 2, 3, 5, 6, 7, 
1, 2, 3, 5, 6, 7, 
0, 1, 2, 3, 5, 6, 7, 
4, 5, 6, 7, 
0, 4, 5, 6, 7, 
1, 4, 5, 6, 7, 
0, 1, 4, 5, 6, 7, 
2, 4, 5, 6, 7, 
0, 2, 4, 5, 6, 7, 
1, 2, 4, 5, 6, 7, 
0, 1, 2, 4, 5, 6, 7, 
3, 4, 5, 6, 7, 
0, 3, 4, 5, 6, 7, 
1, 3, 4, 5, 6, 7, 
0, 1, 3, 4, 5, 6, 7, 
2, 3, 4, 5, 6, 7, 
0, 2, 3, 4, 5, 6, 7, 
1, 2, 3, 4, 5, 6, 7, 
0, 1, 2, 3, 4, 5, 6, 7, 
```


```c++
int n = 4;
std::vector<int> a = {0, 1, 2, 3};
//二进制枚举//枚举每一个状态
for (int i = 0; i < (1 << n); i++)
{
    std::wstringstream wsLog;
    wsLog << i << L": ";
    //枚举该状态下二进制的每一位数值
    for (int j = 0; j < n; j++)
    {
        //当前状态的第i位  是否为1(存在
        if (i & (1 << j))
        {
            wsLog << a[j] << L", ";
        }
    }
    wsLog << L"\n";
    OutputDebugString(wsLog.str().c_str());
}
```

```
0: 
1: 0, 
2: 1, 
3: 0, 1, 
4: 2, 
5: 0, 2, 
6: 1, 2, 
7: 0, 1, 2, 
8: 3, 
9: 0, 3, 
10: 1, 3, 
11: 0, 1, 3, 
12: 2, 3, 
13: 0, 2, 3, 
14: 1, 2, 3, 
15: 0, 1, 2, 3, 
```